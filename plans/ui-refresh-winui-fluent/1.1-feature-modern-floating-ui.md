# PR 1.1: Enhanced Floating Window & Quick Resize Interface

**Branch Name:** `feature/modern-floating-ui`

**Description:** Redesigns the floating quick-resize window with modern Fluent styling, improved spacing, preset button hierarchy, and refined sizing logic (400x450) while preserving all existing behavior.

**Technology Stack:** WinUI 3 (Windows App SDK 1.8), .NET 8, XAML, C#

**Dependencies:** None

**Part of Phase:** Phase 1 – Modern UI Refresh (initial visual upgrade foundation)

## Pre-Implementation Checklist

 - [x] **Branch Creation:** If not already on the main/default branch, run:
  ```bash
  cd x:/burkeholland/ResizeMe
  git checkout main
  git pull
  git checkout -b 1.1-feature-modern-floating-ui
  ```

 - [x] **Verify Project Setup:** Ensure the project builds/runs successfully
  ```bash
  dotnet build ResizeMe.sln
  ```
  Expected output: `Build succeeded.` No XAML parse errors; `ResizeMe` project compiles for all target frameworks.

## Implementation Steps

### Step 1: Update Shared Styles & Tokens (`App.xaml`)

**Goal:** Provide consistent spacing and button styles used by the floating window (preset buttons, toolbar icon, primary actions) following Fluent guidance.

**File to Edit:** `ResizeMe/App.xaml`

**Checklist:**
 - [x] Append or replace resource dictionary ensuring WinUI controls merged
 - [x] Define spacing, preset button styles (`PresetButtonBaseStyle`, `ActivePresetButtonStyle`)
 - [x] Define `PrimaryActionButtonStyle` and `ToolbarIconButtonStyle`
 - [x] Ensure no duplicate keys causing resource collision
 - [x] Copy and paste the entire content below:

```xml
<?xml version="1.0" encoding="utf-8"?>
<Application
    x:Class="ResizeMe.App"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:ResizeMe">
    <Application.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <XamlControlsResources xmlns="using:Microsoft.UI.Xaml.Controls" />
            </ResourceDictionary.MergedDictionaries>

            <!-- Spacing tokens (Fluent scale approximation) -->
            <x:Double x:Key="SpacingXS">4</x:Double>
            <x:Double x:Key="SpacingSM">8</x:Double>
            <x:Double x:Key="SpacingMD">12</x:Double>
            <x:Double x:Key="SpacingLG">16</x:Double>

            <!-- Base style for preset buttons -->
            <Style x:Key="PresetButtonBaseStyle" TargetType="Button" BasedOn="{StaticResource DefaultButtonStyle}">
                <Setter Property="MinHeight" Value="64"/>
                <Setter Property="HorizontalAlignment" Value="Stretch"/>
                <Setter Property="HorizontalContentAlignment" Value="Left"/>
                <Setter Property="VerticalContentAlignment" Value="Center"/>
                <Setter Property="Padding" Value="16,12"/>
                <Setter Property="CornerRadius" Value="8"/>
                <Setter Property="Background" Value="{ThemeResource ControlFillColorSecondaryBrush}"/>
                <Setter Property="BorderBrush" Value="{ThemeResource ControlStrokeColorSecondaryBrush}"/>
                <Setter Property="BorderThickness" Value="1"/>
                <Setter Property="ToolTipService.ToolTip" Value="Resize to preset dimensions"/>
                <Setter Property="Margin" Value="0,0,0,8"/>
            </Style>

            <!-- Active (selected) preset style -->
            <Style x:Key="ActivePresetButtonStyle" TargetType="Button" BasedOn="{StaticResource PresetButtonBaseStyle}">
                <Setter Property="Background" Value="{ThemeResource AccentFillColorDefaultBrush}"/>
                <Setter Property="Foreground" Value="{ThemeResource TextOnAccentFillColorPrimaryBrush}"/>
                <Setter Property="BorderBrush" Value="{ThemeResource AccentStrokeColorDefaultBrush}"/>
            </Style>

            <!-- Preset header text -->
            <Style x:Key="PresetHeaderTextStyle" TargetType="TextBlock" BasedOn="{StaticResource BodyStrongTextBlockStyle}">
                <Setter Property="FontSize" Value="14"/>
                <Setter Property="TextWrapping" Value="Wrap"/>
            </Style>

            <!-- Preset sub text -->
            <Style x:Key="PresetSubTextStyle" TargetType="TextBlock" BasedOn="{StaticResource CaptionTextBlockStyle}">
                <Setter Property="Opacity" Value="0.78"/>
            </Style>

            <!-- Primary action button (future use) -->
            <Style x:Key="PrimaryActionButtonStyle" TargetType="Button" BasedOn="{StaticResource DefaultButtonStyle}">
                <Setter Property="Padding" Value="14,8"/>
                <Setter Property="CornerRadius" Value="6"/>
                <Setter Property="Background" Value="{ThemeResource AccentFillColorDefaultBrush}"/>
                <Setter Property="Foreground" Value="{ThemeResource TextOnAccentFillColorPrimaryBrush}"/>
                <Setter Property="BorderBrush" Value="{ThemeResource ControlStrokeColorDefaultBrush}"/>
                <Setter Property="BorderThickness" Value="1"/>
            </Style>

            <!-- Toolbar icon button (Settings button) -->
            <Style x:Key="ToolbarIconButtonStyle" TargetType="Button" BasedOn="{StaticResource SubtleButtonStyle}">
                <Setter Property="Width" Value="32"/>
                <Setter Property="Height" Value="32"/>
                <Setter Property="Padding" Value="4"/>
                <Setter Property="CornerRadius" Value="4"/>
            </Style>
        </ResourceDictionary>
    </Application.Resources>
</Application>
```

**Verification:**
- [ ] File saves with no XAML errors (no red squiggles).
- [ ] IntelliSense shows new style keys in `MainWindow.xaml`.
- [ ] Build succeeds without resource key duplication warnings.

---

### Step 2: Modernize Floating Window Layout (`MainWindow.xaml`)

**Goal:** Apply card-based Fluent layout, clear hierarchy (Header / Content / Footer), and ensure preset list spacing and hint styling.

**File to Edit:** `ResizeMe/MainWindow.xaml`

**Checklist:**
 - [x] Ensure Mica backdrop remains (`BaseAlt`) for subtle contrast.
 - [x] Header: App glyph, title, status text, Settings button styled.
 - [x] Content: ScrollViewer with `DynamicPresetsPanel` and hint.
 - [x] Footer: Non-interactive usage tip.
 - [x] MinWidth maintained (360) and MaxWidth (400) for stable sizing.
 - [x] Copy and paste entire content below:

```xml
<?xml version="1.0" encoding="utf-8"?>
<Window
    x:Class="ResizeMe.MainWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    Title="ResizeMe">
    <Window.SystemBackdrop>
        <MicaBackdrop Kind="BaseAlt" />
    </Window.SystemBackdrop>

    <Grid x:Name="RootGrid"
          Background="{ThemeResource LayerFillColorDefaultBrush}"
          Padding="16"
          MaxWidth="400"
          MinWidth="360">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>

        <!-- Header Card -->
        <Border Grid.Row="0"
                Background="{ThemeResource CardBackgroundFillColorDefaultBrush}"
                CornerRadius="8"
                BorderThickness="1"
                BorderBrush="{ThemeResource CardStrokeColorDefaultBrush}"
                Margin="0,0,0,12"
                Padding="16,12">
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto" />
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="Auto" />
                </Grid.ColumnDefinitions>
                <FontIcon Grid.Column="0"
                          FontFamily="Segoe Fluent Icons"
                          Glyph="&#xE8B9;"
                          FontSize="20"
                          Foreground="{ThemeResource AccentTextFillColorPrimaryBrush}"
                          VerticalAlignment="Center" />
                <StackPanel Grid.Column="1"
                            Margin="12,0,12,0"
                            VerticalAlignment="Center">
                    <TextBlock Text="ResizeMe"
                               FontWeight="SemiBold"
                               FontSize="16"
                               Foreground="{ThemeResource TextFillColorPrimaryBrush}" />
                    <TextBlock x:Name="StatusText"
                               Text="Ready"
                               FontSize="12"
                               Foreground="{ThemeResource TextFillColorSecondaryBrush}" />
                </StackPanel>
                <Button x:Name="SettingsButton"
                        Grid.Column="2"
                        Style="{StaticResource ToolbarIconButtonStyle}"
                        ToolTipService.ToolTip="Settings"
                        Click="SettingsButton_Click"
                        VerticalAlignment="Center">
                    <FontIcon FontFamily="Segoe Fluent Icons"
                              Glyph="&#xE713;"
                              FontSize="16" />
                </Button>
            </Grid>
        </Border>

        <!-- Content Card -->
        <Border Grid.Row="1"
                Background="{ThemeResource CardBackgroundFillColorDefaultBrush}"
                CornerRadius="8"
                BorderThickness="1"
                BorderBrush="{ThemeResource CardStrokeColorDefaultBrush}"
                Padding="16">
            <ScrollViewer VerticalScrollBarVisibility="Auto"
                          HorizontalScrollBarVisibility="Disabled">
                <StackPanel Spacing="16">
                    <TextBlock Text="Quick Resize"
                               FontWeight="SemiBold"
                               FontSize="18"
                               Foreground="{ThemeResource TextFillColorPrimaryBrush}" />
                    <StackPanel x:Name="DynamicPresetsPanel"
                                Orientation="Vertical"
                                Spacing="8" />
                    <TextBlock x:Name="PresetHint"
                               Text="Customize presets in Settings"
                               FontSize="12"
                               Foreground="{ThemeResource TextFillColorSecondaryBrush}"
                               HorizontalAlignment="Center"
                               Margin="0,8,0,0" />
                </StackPanel>
            </ScrollViewer>
        </Border>

        <!-- Footer -->
        <Border Grid.Row="2"
                Background="{ThemeResource CardBackgroundFillColorSecondaryBrush}"
                CornerRadius="8"
                BorderThickness="1"
                BorderBrush="{ThemeResource CardStrokeColorDefaultBrush}"
                Padding="16,12"
                Margin="0,12,0,0">
            <TextBlock Text="Win+Shift+F12 to toggle"
                       FontSize="12"
                       Foreground="{ThemeResource TextFillColorSecondaryBrush}"
                       HorizontalAlignment="Center" />
        </Border>
    </Grid>
</Window>
```

**Verification:**
- [ ] Build: no XAML parse errors.
- [ ] Window shows header, content, footer with correct spacing.
- [ ] Settings button tooltip appears on hover.

---

### Step 3: Adjust Window Sizing & Initialize Behavior (`MainWindow.xaml.cs`)

**Goal:** Confirm initial hidden state, resize to 400x450, ensure hotkey registration + style application order.

**File to Edit:** `ResizeMe/MainWindow.xaml.cs`

**Checklist:**
 - [x] Preserve existing logic; adjust comments to clarify sizing.
 - [x] Maintain debounce logic and animation methods.
 - [x] Ensure `LoadPresetButtons()` uses styles defined in `App.xaml`.
- [ ] Copy and paste entire content below (replacing file):

```csharp
using Microsoft.UI;
using Microsoft.UI.Windowing;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using Microsoft.UI.Xaml.Input;
using Microsoft.UI.Text;
using ResizeMe.Native;
using ResizeMe.Services;
using ResizeMe.Models;
using ResizeMe.Helpers;
using WinRT.Interop;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using Windows.Graphics;

namespace ResizeMe
{
    /// <summary>
    /// Floating context menu window providing preset resize buttons with toggle behavior.
    /// </summary>
    public sealed partial class MainWindow : Window
    {
        public event RoutedEventHandler? Loaded;
        private HotKeyManager? _hotKeyManager;
        private WindowManager? _windowManager;
        private WindowResizer? _windowResizer;
        private readonly PresetManager _presetManager = new();
        private IntPtr _windowHandle = IntPtr.Zero;
        private AppWindow? _appWindow;
        private bool _isSubclassRegistered;
        private bool _isVisible;
        private bool _isAlwaysOnTop;
        private WindowInfo? _selectedWindow;
        private List<WindowInfo> _availableWindows = new();
        private string? _activePresetTag;
        private int _presetIndex = -1;
        private TrayIconManager? _trayIcon;

        private WinApiSubClass.SubClassProc? _subclassProc;
        private readonly IntPtr _subClassId = new(1001);
        private DateTime _lastToggle = DateTime.MinValue;

        public MainWindow()
        {
            InitializeComponent();
            _windowManager = new WindowManager();
            _windowResizer = new WindowResizer();
            AttachWindowLoadedHandler();
            Loaded += async (_, _) => { await _presetManager.LoadAsync(); LoadPresetButtons(); };
            SetupWindowAppearance();
            AttachKeyDownHandler();
            Activated += OnWindowActivated;
            Closed += Window_Closed;
        }

        private void AttachWindowLoadedHandler()
        {
            if (Content is FrameworkElement root)
            {
                root.Loaded += Root_Loaded;
            }
            else
            {
                DispatcherQueue.TryEnqueue(async () =>
                {
                    await _presetManager.LoadAsync();
                    LoadPresetButtons();
                });
            }
        }

        private void Root_Loaded(object sender, RoutedEventArgs e)
        {
            if (Content is FrameworkElement root)
            {
                root.Loaded -= Root_Loaded;
            }
            Loaded?.Invoke(this, e);
        }

        private void AttachKeyDownHandler()
        {
            if (Content is FrameworkElement element)
            {
                element.KeyDown -= OnKeyDown;
                element.KeyDown += OnKeyDown;
            }
        }

        private void SetupWindowAppearance()
        {
            try
            {
                Title = "ResizeMe";
                // Standard system title bar retained. Window starts hidden.
                EnsureWindowHandle();
                if (_windowHandle != IntPtr.Zero)
                {
                    var windowId = Win32Interop.GetWindowIdFromWindow(_windowHandle);
                    _appWindow = AppWindow.GetFromWindowId(windowId);
                    // Target size derived from layout cards (Header + Content + Footer)
                    _appWindow?.Resize(new SizeInt32(400, 450));
                    WindowsApi.ShowWindow(_windowHandle, WindowsApi.SW_HIDE);
                }
                _isVisible = false;
                StatusText.Text = "Ready";
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"SetupWindowAppearance error: {ex.Message}");
            }
        }

        private void EnsureWindowHandle()
        {
            if (_windowHandle != IntPtr.Zero) return;
            _windowHandle = WindowNative.GetWindowHandle(this);
            if (_windowHandle != IntPtr.Zero && _appWindow == null)
            {
                var windowId = Win32Interop.GetWindowIdFromWindow(_windowHandle);
                _appWindow = AppWindow.GetFromWindowId(windowId);
            }
        }

        private void EnsureHotKeyRegistration()
        {
            EnsureWindowHandle();
            if (_windowHandle == IntPtr.Zero || _hotKeyManager != null) return;
            _hotKeyManager = new HotKeyManager(_windowHandle);
            _hotKeyManager.HotKeyPressed += (_, _) => ToggleVisibility();
            bool success = _hotKeyManager.RegisterHotKey();
            StatusText.Text = success ? "Ready" : "Hotkey failed";
            if (!_isSubclassRegistered)
            {
                _subclassProc = WndProcSubClass;
                if (WinApiSubClass.SetWindowSubclass(_windowHandle, _subclassProc, _subClassId, IntPtr.Zero))
                {
                    _isSubclassRegistered = true;
                }
            }
            if (_trayIcon == null && _windowHandle != IntPtr.Zero)
            {
                _trayIcon = new TrayIconManager(_windowHandle);
                if (_trayIcon.Initialize())
                {
                    Debug.WriteLine("Tray icon initialized");
                }
            }
            HideWindow();
        }

        private void ToggleVisibility()
        {
            if ((DateTime.UtcNow - _lastToggle).TotalMilliseconds < 150) return; // Debounce
            _lastToggle = DateTime.UtcNow;
            if (_isVisible) HideWindow(); else ShowWindow();
        }

        private void ShowWindow()
        {
            try
            {
                EnsureWindowHandle();
                RefreshWindowList();
                var anchorWindow = _windowManager?.GetActiveResizableWindow() ?? _availableWindows.FirstOrDefault();
                if (anchorWindow != null) WindowPositionHelper.CenterOnWindow(this, anchorWindow); else WindowPositionHelper.CenterOnScreen(this);
                if (_windowHandle != IntPtr.Zero)
                {
                    WindowsApi.ShowWindow(_windowHandle, WindowsApi.SW_RESTORE);
                    WindowsApi.SetForegroundWindow(_windowHandle);
                    ApplyAlwaysOnTop();
                }
                Activate();
                _isVisible = true;
                StatusText.Text = "Menu shown";
                LoadPresetButtons();
                AnimateShow();
            }
            catch (Exception ex)
            {
                StatusText.Text = "Show error";
                Debug.WriteLine($"ShowWindow error: {ex.Message}");
            }
        }

        private void HideWindow()
        {
            try
            {
                AnimateHide();
                EnsureWindowHandle();
                if (_windowHandle != IntPtr.Zero) WindowsApi.ShowWindow(_windowHandle, WindowsApi.SW_HIDE);
                _isVisible = false;
                _presetIndex = -1;
                StatusText.Text = "Hidden";
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"HideWindow error: {ex.Message}");
            }
        }

        private void RefreshWindowList()
        {
            try
            {
                if (_windowManager == null) return;
                _availableWindows = _windowManager.GetResizableWindows().ToList();
                var activeWindow = _windowManager.GetActiveResizableWindow();
                _selectedWindow = activeWindow ?? _availableWindows.FirstOrDefault();
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"RefreshWindowList error: {ex.Message}");
            }
        }

        private void LoadPresetButtons()
        {
            if (DynamicPresetsPanel == null) return;
            DynamicPresetsPanel.Children.Clear();

            Style? baseStyle = null;
            Style? activeStyle = null;
            var resources = App.Current?.Resources;
            if (resources != null)
            {
                if (resources.TryGetValue("PresetButtonBaseStyle", out var baseStyleObj) && baseStyleObj is Style basePresetStyle) baseStyle = basePresetStyle;
                if (resources.TryGetValue("ActivePresetButtonStyle", out var activeStyleObj) && activeStyleObj is Style activePresetStyle) activeStyle = activePresetStyle;
            }

            foreach (var preset in _presetManager.Presets)
            {
                string glyph = preset.Width switch
                {
                    <= 1024 => "\xE7F8",
                    <= 1366 => "\xE80A",
                    <= 1920 => "\xE959",
                    _ => "\xE9F9"
                };

                var stack = new StackPanel
                {
                    Orientation = Orientation.Horizontal,
                    Spacing = 12,
                    Children =
                    {
                        new FontIcon{FontFamily=new Microsoft.UI.Xaml.Media.FontFamily("Segoe Fluent Icons"), Glyph=glyph, FontSize=20, Opacity=0.9},
                        new StackPanel
                        {
                            Orientation = Orientation.Vertical,
                            Spacing = 2,
                            VerticalAlignment = VerticalAlignment.Center,
                            Children =
                            {
                                new TextBlock{Text=preset.Name, FontWeight= FontWeights.SemiBold, FontSize=16},
                                new TextBlock{Text=$"{preset.Width} × {preset.Height}", Opacity=0.8, FontSize=13}
                            }
                        }
                    }
                };

                var btn = new Button
                {
                    Content = stack,
                    Tag = $"{preset.Width}x{preset.Height}",
                    Margin = new Thickness(0,0,0,0)
                };
                if (baseStyle != null) btn.Style = baseStyle;
                btn.MinHeight = 64;
                btn.Padding = new Thickness(16, 12, 16, 12);
                btn.HorizontalContentAlignment = HorizontalAlignment.Left;
                btn.VerticalContentAlignment = VerticalAlignment.Center;
                btn.Click += PresetButton_Click;
                DynamicPresetsPanel.Children.Add(btn);
            }

            if (!_presetManager.Presets.Any())
            {
                PresetHint.Text = "No presets defined. Add in Settings.";
                _presetIndex = -1;
            }
            else
            {
                PresetHint.Text = "Customize in Settings";
                FocusPreset(0);
            }
        }

        private void FocusPreset(int index)
        {
            if (DynamicPresetsPanel == null) return;
            var buttons = DynamicPresetsPanel.Children.OfType<Button>().ToList();
            if (!buttons.Any()) return;
            if (index < 0) index = 0;
            if (index >= buttons.Count) index = buttons.Count - 1;
            _presetIndex = index;
            buttons[index].Focus(FocusState.Programmatic);
        }

        private async Task ResizeSelectedWindow(int width, int height, string sizeTag)
        {
            try
            {
                var targetWindow = _selectedWindow ?? _availableWindows.FirstOrDefault();
                if (targetWindow == null) { StatusText.Text = "No window"; return; }
                if (_windowResizer == null) { StatusText.Text = "No resizer"; return; }
                StatusText.Text = $"Resizing {sizeTag}...";
                var result = _windowResizer.ResizeWindow(targetWindow, width, height);
                if (result.Success)
                {
                    StatusText.Text = $"✅ {sizeTag}";
                    _windowResizer.ActivateWindow(targetWindow);
                    SetActivePreset(sizeTag);
                    await Task.Delay(600);
                    HideWindow();
                }
                else
                {
                    StatusText.Text = $"❌ {result.ErrorMessage}";
                }
            }
            catch (Exception ex)
            {
                StatusText.Text = "Resize failed";
                Debug.WriteLine($"ResizeSelectedWindow error: {ex.Message}");
            }
        }

        private void SetActivePreset(string sizeTag)
        {
            _activePresetTag = sizeTag;
            Style? activeStyle = null; Style? baseStyle = null;
            var resources = App.Current?.Resources;
            if (resources != null)
            {
                if (resources.TryGetValue("ActivePresetButtonStyle", out var activeObj) && activeObj is Style activePresetStyle) activeStyle = activePresetStyle;
                if (resources.TryGetValue("PresetButtonBaseStyle", out var baseObj) && baseObj is Style basePresetStyle) baseStyle = basePresetStyle;
            }
            if (DynamicPresetsPanel == null || activeStyle == null || baseStyle == null) return;
            foreach (var child in DynamicPresetsPanel.Children.OfType<Button>())
                child.Style = child.Tag is string tag && tag == sizeTag ? activeStyle : baseStyle;
        }

        private void PresetButton_Click(object sender, RoutedEventArgs e)
        {
            if (sender is not Button btn || btn.Tag is not string sizeTag) return;
            var parts = sizeTag.Split('x');
            if (parts.Length != 2 || !int.TryParse(parts[0], out int width) || !int.TryParse(parts[1], out int height)) { StatusText.Text = "Invalid size"; return; }
            _ = ResizeSelectedWindow(width, height, sizeTag);
        }

        private void OnKeyDown(object sender, KeyRoutedEventArgs e)
        {
            if (!_isVisible) return;
            var buttons = DynamicPresetsPanel?.Children.OfType<Button>().ToList();
            switch (e.Key)
            {
                case Windows.System.VirtualKey.Escape:
                    HideWindow(); e.Handled = true; break;
                case Windows.System.VirtualKey.Right:
                case Windows.System.VirtualKey.Down:
                    if (buttons != null && buttons.Count > 0) { FocusPreset(_presetIndex + 1); e.Handled = true; }
                    break;
                case Windows.System.VirtualKey.Left:
                case Windows.System.VirtualKey.Up:
                    if (buttons != null && buttons.Count > 0) { FocusPreset(_presetIndex - 1); e.Handled = true; }
                    break;
                case Windows.System.VirtualKey.Enter:
                    if (buttons != null && _presetIndex >= 0 && _presetIndex < buttons.Count) { PresetButton_Click(buttons[_presetIndex], new RoutedEventArgs()); e.Handled = true; }
                    break;
            }
        }

        private void OnWindowActivated(object sender, WindowActivatedEventArgs args)
        {
            if (args.WindowActivationState == WindowActivationState.Deactivated)
            {
                if (_isVisible && !_isAlwaysOnTop)
                {
                    _ = Task.Run(async () =>
                    {
                        await Task.Delay(150);
                        DispatcherQueue.TryEnqueue(HideWindow);
                    });
                }
                return;
            }
            EnsureHotKeyRegistration();
        }

        private void AlwaysOnTopButton_Click(object sender, RoutedEventArgs e)
        {
            _isAlwaysOnTop = !_isAlwaysOnTop;
            ApplyAlwaysOnTop();
            StatusText.Text = _isAlwaysOnTop ? "Pinned" : "Normal";
        }

        private void ApplyAlwaysOnTop()
        {
            if (_windowHandle == IntPtr.Zero) return;
            var insertAfter = _isAlwaysOnTop ? WindowsApi.HWND_TOPMOST : WindowsApi.HWND_NOTOPMOST;
            WindowsApi.SetWindowPos(_windowHandle, insertAfter, 0, 0, 0, 0, WindowsApi.SWP_NOMOVE | WindowsApi.SWP_NOSIZE | WindowsApi.SWP_NOACTIVATE);
        }

        private void Window_Closed(object sender, WindowEventArgs e)
        {
            _trayIcon?.Dispose();
            _hotKeyManager?.Dispose();
            if (_isSubclassRegistered && _windowHandle != IntPtr.Zero && _subclassProc != null)
            {
                WinApiSubClass.RemoveWindowSubclass(_windowHandle, _subclassProc, _subClassId);
                _isSubclassRegistered = false;
            }
        }

        private IntPtr WndProcSubClass(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam, IntPtr uIdSubclass, IntPtr dwRefData)
        {
            if (_hotKeyManager?.ProcessMessage(uMsg, wParam, lParam) == true) return IntPtr.Zero;
            return WinApiSubClass.DefSubclassProc(hWnd, uMsg, wParam, lParam);
        }

        private void SettingsButton_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                var win = new SettingsWindow();
                win.PresetsChanged += OnSettingsPresetsChanged;
                win.Closed += async (_, _) =>
                {
                    win.PresetsChanged -= OnSettingsPresetsChanged;
                    await _presetManager.LoadAsync(true);
                    DispatcherQueue.TryEnqueue(LoadPresetButtons);
                };
                win.Activate();
                StatusText.Text = "Settings opened";
            }
            catch (Exception ex)
            {
                StatusText.Text = "Settings failed";
                Debug.WriteLine($"Settings open error: {ex.Message}");
            }
        }

        private async void OnSettingsPresetsChanged(object? sender, EventArgs e)
        {
            await _presetManager.LoadAsync(true);
            DispatcherQueue.TryEnqueue(LoadPresetButtons);
        }

        private void AnimateShow()
        {
            if (RootGrid == null) return;
            RootGrid.Opacity = 0;
            var animation = RootGrid.CreateDoubleAnimation(0, 1, 180);
            var visual = Microsoft.UI.Xaml.Hosting.ElementCompositionPreview.GetElementVisual(RootGrid);
            var compositor = visual.Compositor;
            var batch = compositor.CreateBatch();
            visual.StartAnimation("Opacity", animation);
            batch.Completed += (_, _) => RootGrid.DispatcherQueue.TryEnqueue(() => RootGrid.Opacity = 1);
            batch.End();
        }

        private void AnimateHide()
        {
            if (RootGrid == null) return;
            var animation = RootGrid.CreateDoubleAnimation(RootGrid.Opacity, 0, 120);
            var visual = Microsoft.UI.Xaml.Hosting.ElementCompositionPreview.GetElementVisual(RootGrid);
            var compositor = visual.Compositor;
            var batch = compositor.CreateBatch();
            visual.StartAnimation("Opacity", animation);
            batch.Completed += (_, _) => RootGrid.DispatcherQueue.TryEnqueue(() => RootGrid.Opacity = 0);
            batch.End();
        }
    }

    internal static class WinApiSubClass
    {
        public delegate IntPtr SubClassProc(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam, IntPtr uIdSubclass, IntPtr dwRefData);
        [DllImport("comctl32.dll")] public static extern bool SetWindowSubclass(IntPtr hWnd, SubClassProc pfnSubclass, IntPtr uIdSubclass, IntPtr dwRefData);
        [DllImport("comctl32.dll")] public static extern IntPtr DefSubclassProc(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam);
        [DllImport("comctl32.dll")] public static extern bool RemoveWindowSubclass(IntPtr hWnd, SubClassProc pfnSubclass, IntPtr uIdSubclass);
    }

    internal static class AnimationExtensions
    {
        public static Microsoft.UI.Composition.CompositionScopedBatch CreateBatch(this Microsoft.UI.Composition.Compositor compositor) => compositor.CreateScopedBatch(Microsoft.UI.Composition.CompositionBatchTypes.Animation);
        public static Microsoft.UI.Composition.CompositionAnimation Start(this Microsoft.UI.Composition.CompositionAnimation animation, UIElement element, string property)
        {
            var visual = Microsoft.UI.Xaml.Hosting.ElementCompositionPreview.GetElementVisual(element);
            visual.StartAnimation(property, animation);
            return animation;
        }
        public static Microsoft.UI.Composition.ScalarKeyFrameAnimation CreateDoubleAnimation(this UIElement element, double from, double to, int durationMs)
        {
            var compositor = Microsoft.UI.Xaml.Hosting.ElementCompositionPreview.GetElementVisual(element).Compositor;
            var anim = compositor.CreateScalarKeyFrameAnimation();
            anim.InsertKeyFrame(0f, (float)from);
            anim.InsertKeyFrame(1f, (float)to);
            anim.Duration = TimeSpan.FromMilliseconds(durationMs);
            return anim;
        }
    }
}
```

**Verification:**
- [ ] Build: no C# compile errors.
- [ ] Runtime: window shows with hotkey toggle operational (Win+Shift+F12).
- [ ] Preset buttons styled; active preset changes visual style.

---

### Step 4: Manual Runtime Validation

**Goal:** Confirm UX matches design and no regressions in interactions.

**File to Edit:** (None – runtime checks)

**Checklist:**
 - [ ] Launch app, press hotkey → window appears centered relative to active window.
 - [ ] Click each preset → target window resizes & menu hides after success.
 - [ ] Open Settings → status updates to "Settings opened" without errors.
 - [ ] Close settings window → presets refresh.

**Verification:**
- [ ] No unexpected flicker on show/hide animations.
- [ ] Tooltips appear and fade per system behavior.

---

## Build and Final Verification

**Checklist:**
 - [x] **Build/Test the project:**
  ```bash
  dotnet build ResizeMe.sln
  ```
  Expected: `Build succeeded.` No warnings referencing updated XAML or missing resources.

 - [x] **Check for errors:**
  - [ ] If XAML error: verify `xmlns` declarations and closing tags.
  - [ ] If style missing: confirm resource keys match exactly (`PresetButtonBaseStyle`, `ActivePresetButtonStyle`).
  - [ ] If hotkey fails: ensure window handle acquired before registration.

 - [ ] **Optional: Manual Testing**
  - [ ] Run app: `dotnet run --project ResizeMe/ResizeMe.csproj`
  - [ ] Trigger hotkey; interact with buttons.
  - [ ] Verify status text updates.

## Expected Behavior After Completion

- [ ] Floating window exhibits modern Fluent card layout.
- [ ] Preset buttons show glyph + name + dimensions with active highlight.
- [ ] Hotkey toggles visibility with debounce preventing accidental double hide/show.
- [ ] Settings button opens settings window and refreshes presets upon close.

## Troubleshooting

| Issue | Solution |
|-------|----------|
| XAML parse error on `App.xaml` | Ensure XML header intact and all `<ResourceDictionary>` tags properly closed. Rebuild after saving. |
| Styles not applied to buttons | Confirm `App.xaml` loaded (it is by default). Check resource key spelling and rebuild. |
| Hotkey does nothing | Verify `EnsureHotKeyRegistration()` runs (activation event). Confirm no other app owns Win+Shift+F12. |
| Tray icon missing | Ensure window handle valid; debug log will note initialization. |
| Preset buttons empty | Ensure `LoadPresetButtons()` called after `_presetManager.LoadAsync()`; check `presets.json` validity or delete to regen defaults. |

## Files Created/Modified

 - [x] ✅ Modified: `ResizeMe/App.xaml`
 - [x] ✅ Modified: `ResizeMe/MainWindow.xaml`
 - [x] ✅ Modified: `ResizeMe/MainWindow.xaml.cs`
- [ ] ✅ No changes: Service layer (`Services/*`) & model classes

## Commit Message Template

```
feat(ui): modernize floating quick-resize window

Implements Fluent-styled floating window (400x450), preset button hierarchy, shared styles, and retained hotkey behavior.

- Adds spacing & style resources
- Applies card layout & animation
- Preserves existing resize logic
```

## Implementation Notes for Reviewers
- Focus confined to presentation; business logic untouched.
- Sizing chosen to avoid vertical scroll for ~6 presets while maintaining compact width.
- Debounce logic maintained; animations use Composition API for smooth opacity transitions.

## What Comes Next
- PR 1.2 (`feature/modern-settings-ui`) refactors `SettingsWindow` with aligned styling and form improvements.
- Enables consistent visual language across configuration and quick action surfaces.
- Future consideration: integrate settings into a page model to remove separate window overhead.
