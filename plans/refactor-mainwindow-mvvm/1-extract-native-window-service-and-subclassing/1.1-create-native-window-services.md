# Step 1.1: Create Native Window Services

**Part of:** Step 1 from plan.md  
**Focus:** Introduce reusable abstractions for HWND/AppWindow access and subclass message handling  
**File to Create/Edit:** `ResizeMe/Native/INativeWindowService.cs`, `ResizeMe/Native/NativeWindowService.cs`, `ResizeMe/Native/WindowSubclassService.cs`  
**Estimated Time:** 15 minutes

## Overview

This substep encapsulates all MainWindow-specific Win32 handle management and subclass hooks into dedicated services. Centralizing this logic makes later refactors possible without re-reading the entire `MainWindow.xaml.cs` file.

## Pre-Substep Checklist

- [ ] **Branch:** Working on `refactor/mainwindow-mvvm`
- [ ] **Current Step:** No prior substeps in Step 1
- [ ] **Codebase State:** `dotnet build ResizeMe.sln` succeeds

## Implementation

### Goal
Create strongly-typed services that provide HWND/AppWindow helpers and encapsulate the subclass procedure currently embedded in `MainWindow`.

### Step-by-Step Instructions

#### Step 1: Define the contracts
- [ ] Create `ResizeMe/Native/INativeWindowService.cs`
- [ ] Create `ResizeMe/Native/IWindowSubclassService.cs`
- [ ] Ensure both interfaces live in the `ResizeMe.Native` namespace
- [ ] Copy and paste the code below into `INativeWindowService.cs`:

```csharp
using System;
using Microsoft.UI.Windowing;
using Microsoft.UI.Xaml;

namespace ResizeMe.Native
{
    public interface INativeWindowService
    {
        IntPtr EnsureWindowHandle(Window window);
        AppWindow? GetAppWindow(Window window);
        void ConfigureShell(AppWindow appWindow, string title, string iconPath, int width, int height);
        void ShowWindow(IntPtr hwnd);
        void HideWindow(IntPtr hwnd);
        void RestoreWindow(IntPtr hwnd);
        void FocusWindow(IntPtr hwnd);
    }
}
```

- [ ] Copy and paste the code below into `IWindowSubclassService.cs`:

```csharp
using System;
using System.Threading.Tasks;

namespace ResizeMe.Native
{
    public interface IWindowMessageHandler
    {
        IntPtr HandleWindowMessage(IntPtr hwnd, uint msg, IntPtr wParam, IntPtr lParam);
    }

    public interface IWindowSubclassService : IDisposable
    {
        Task<bool> AttachAsync(IntPtr hwnd, IWindowMessageHandler handler);
        void Detach();
    }
}
```

#### Step 2: Implement the services
- [ ] Create `ResizeMe/Native/NativeWindowService.cs`
- [ ] Create `ResizeMe/Native/WindowSubclassService.cs`
- [ ] Copy and paste the implementation for `NativeWindowService`:

```csharp
using System;
using System.IO;
using Microsoft.UI.Windowing;
using Microsoft.UI.Xaml;
using ResizeMe.Shared.Logging;
using WinRT.Interop;

namespace ResizeMe.Native
{
    public sealed class NativeWindowService : INativeWindowService
    {
        private readonly string _logger = nameof(NativeWindowService);

        public IntPtr EnsureWindowHandle(Window window)
        {
            ArgumentNullException.ThrowIfNull(window);
            var hwnd = WindowNative.GetWindowHandle(window);
            if (hwnd == IntPtr.Zero)
            {
                AppLog.Error(_logger, "Window handle could not be resolved.");
                throw new InvalidOperationException("Window handle unavailable");
            }
            return hwnd;
        }

        public AppWindow? GetAppWindow(Window window)
        {
            ArgumentNullException.ThrowIfNull(window);
            var hwnd = WindowNative.GetWindowHandle(window);
            if (hwnd == IntPtr.Zero)
            {
                return null;
            }

            var windowId = Win32Interop.GetWindowIdFromWindow(hwnd);
            return AppWindow.GetFromWindowId(windowId);
        }

        public void ConfigureShell(AppWindow appWindow, string title, string iconPath, int width, int height)
        {
            ArgumentNullException.ThrowIfNull(appWindow);
            appWindow.Title = title;
            if (!string.IsNullOrWhiteSpace(iconPath) && File.Exists(iconPath))
            {
                appWindow.SetIcon(iconPath);
            }

            appWindow.Resize(new Windows.Graphics.SizeInt32(width, height));
        }

        public void ShowWindow(IntPtr hwnd)
        {
            if (hwnd == IntPtr.Zero)
            {
                return;
            }
            WindowsApi.ShowWindow(hwnd, WindowsApi.SW_SHOW);
        }

        public void HideWindow(IntPtr hwnd)
        {
            if (hwnd == IntPtr.Zero)
            {
                return;
            }
            WindowsApi.ShowWindow(hwnd, WindowsApi.SW_HIDE);
        }

        public void RestoreWindow(IntPtr hwnd)
        {
            if (hwnd == IntPtr.Zero)
            {
                return;
            }
            WindowsApi.ShowWindow(hwnd, WindowsApi.SW_RESTORE);
        }

        public void FocusWindow(IntPtr hwnd)
        {
            if (hwnd == IntPtr.Zero)
            {
                return;
            }
            WindowsApi.SetForegroundWindow(hwnd);
        }
    }
}
```

- [ ] Copy and paste the implementation for `WindowSubclassService`:

```csharp
using System;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using ResizeMe.Shared.Logging;

namespace ResizeMe.Native
{
    public sealed class WindowSubclassService : IWindowSubclassService
    {
        private readonly string _logger = nameof(WindowSubclassService);
        private IWindowMessageHandler? _handler;
        private WindowsApi.SubClassProc? _callback;
        private IntPtr _hwnd;
        private IntPtr _subclassId = new(1001);
        private bool _attached;

        public async Task<bool> AttachAsync(IntPtr hwnd, IWindowMessageHandler handler)
        {
            ArgumentNullException.ThrowIfNull(handler);
            if (hwnd == IntPtr.Zero)
            {
                throw new ArgumentException("HWND must be valid", nameof(hwnd));
            }
            if (_attached)
            {
                return true;
            }

            _handler = handler;
            _hwnd = hwnd;
            _callback = HandleMessage;
            _attached = WinApiSubClass.SetWindowSubclass(hwnd, _callback, _subclassId, IntPtr.Zero);
            if (!_attached)
            {
                AppLog.Warn(_logger, "SetWindowSubclass returned false.");
            }
            return await Task.FromResult(_attached);
        }

        public void Detach()
        {
            if (!_attached || _callback == null || _hwnd == IntPtr.Zero)
            {
                return;
            }

            WinApiSubClass.RemoveWindowSubclass(_hwnd, _callback, _subclassId);
            _attached = false;
            _handler = null;
            _callback = null;
            _hwnd = IntPtr.Zero;
        }

        public void Dispose()
        {
            Detach();
            GC.SuppressFinalize(this);
        }

        private IntPtr HandleMessage(IntPtr hwnd, uint msg, IntPtr wParam, IntPtr lParam, IntPtr subclassId, IntPtr refData)
        {
            if (_handler != null)
            {
                var handled = _handler.HandleWindowMessage(hwnd, msg, wParam, lParam);
                if (handled != IntPtr.Zero)
                {
                    return handled;
                }
            }

            return WinApiSubClass.DefSubclassProc(hwnd, msg, wParam, lParam);
        }

        private static class WinApiSubClass
        {
            public delegate IntPtr SubClassProc(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam, IntPtr uIdSubclass, IntPtr dwRefData);

            [DllImport("comctl32.dll", ExactSpelling = true)]
            public static extern bool SetWindowSubclass(IntPtr hWnd, WindowsApi.SubClassProc pfnSubclass, IntPtr uIdSubclass, IntPtr dwRefData);

            [DllImport("comctl32.dll", ExactSpelling = true)]
            public static extern bool RemoveWindowSubclass(IntPtr hWnd, WindowsApi.SubClassProc pfnSubclass, IntPtr uIdSubclass);

            [DllImport("comctl32.dll", ExactSpelling = true)]
            public static extern IntPtr DefSubclassProc(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam);
        }
    }
}
```

#### Step 3: Update WindowsApi with nested delegate (if missing)
- [ ] Ensure `WindowsApi` exposes `SubClassProc` delegate so the service can reuse it (already defined at bottom of `MainWindow.xaml.cs`—move to `WindowsApi`)
- [ ] Append this delegate inside `WindowsApi`:

```csharp
public static class WindowsApi
{
    public delegate IntPtr SubClassProc(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam, IntPtr uIdSubclass, IntPtr dwRefData);
    // ...existing declarations...
}
```

## Verification Checklist

- [ ] Files created under `ResizeMe/Native/`
- [ ] `dotnet build ResizeMe.sln` succeeds
- [ ] No compiler warnings about unused fields (`_handler`, `_callback`)

## Troubleshooting

| Issue | Solution |
|-------|----------|
| `type or namespace name 'SubClassProc' could not be found` | Confirm the delegate is declared in `WindowsApi` and namespace imported in `WindowSubclassService.cs`. |
| `P/Invoke StackImbalance` warnings | Ensure `DllImport` attributes use `ExactSpelling = true` and signature matches Win32 prototypes. |

## Files Modified

- [ ] ✅ Created: `ResizeMe/Native/INativeWindowService.cs`
- [ ] ✅ Created: `ResizeMe/Native/IWindowSubclassService.cs`
- [ ] ✅ Created: `ResizeMe/Native/NativeWindowService.cs`
- [ ] ✅ Created: `ResizeMe/Native/WindowSubclassService.cs`
- [ ] ✅ Updated: `ResizeMe/Native/WindowsApi.cs`

## What Comes Next

- Next substep: Step 1.2 – Inject `INativeWindowService` and `IWindowSubclassService` into `MainWindow`
- Build and run once both substeps in Step 1 are complete
