# Step 1.2: Integrate Native Services into MainWindow

**Part of:** Step 1 from plan.md  
**Focus:** Replace direct Win32 handling in `MainWindow.xaml.cs` with the new services  
**File to Edit:** `ResizeMe/MainWindow.xaml.cs`  
**Estimated Time:** 15 minutes

## Overview

With the services created in Step 1.1, wire them into `MainWindow` so the window handle, AppWindow configuration, and subclass callback are owned by reusable helpers. This shrinks the code-behind and prepares it for MVVM.

## Pre-Substep Checklist

- [ ] **Branch:** `refactor/mainwindow-mvvm`
- [ ] **Current Step:** Step 1.1 completed (services exist)
- [ ] **Codebase State:** Clean build: `dotnet build ResizeMe.sln`

## Implementation

### Goal
Inject `INativeWindowService` and `IWindowSubclassService` into `MainWindow`, removing direct `WindowNative`, `Win32Interop`, and nested subclass class usage.

### Step-by-Step Instructions

#### Step 1: Add dependencies
- [ ] At top of `MainWindow.xaml.cs`, add `using ResizeMe.Native;`
- [ ] Introduce private readonly fields:

```csharp
private readonly INativeWindowService _nativeWindowService = new NativeWindowService();
private readonly IWindowSubclassService _subclassService = new WindowSubclassService();
```

- [ ] Remove `_messageBridge`, `_subclassProc`, `_subclassId`, `_subclassAttached` fields—they are now encapsulated.

#### Step 2: Replace handle + shell code
- [ ] Replace `EnsureWindowHandle` body with service calls:

```csharp
private void EnsureWindowHandle()
{
    if (_windowHandle != IntPtr.Zero)
    {
        return;
    }

    _windowHandle = _nativeWindowService.EnsureWindowHandle(this);
    _appWindow = _nativeWindowService.GetAppWindow(this);
}
```

- [ ] Update `ConfigureShell` to defer to service:

```csharp
private void ConfigureShell()
{
    try
    {
        if (_appWindow == null)
        {
            return;
        }

        var iconPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Assets", "AppIcon.ico");
        _nativeWindowService.ConfigureShell(_appWindow, "ResizeMe", iconPath, 320, 540);
    }
    catch (Exception ex)
    {
        AppLog.Warn(nameof(MainWindow), $"ConfigureShell failed: {ex.Message}");
    }
}
```

#### Step 3: Attach subclass via service
- [ ] Replace `AttachSubclass` contents with:

```csharp
private async void AttachSubclass()
{
    if (_windowHandle == IntPtr.Zero)
    {
        return;
    }

    var handler = new WindowMessageHandler(this);
    await _subclassService.AttachAsync(_windowHandle, handler);
}
```

- [ ] Delete nested `WindowMessageBridge` class and replace with `WindowMessageHandler` implementing `IWindowMessageHandler` (same message logic but without subclass plumbing):

```csharp
private sealed class WindowMessageHandler : IWindowMessageHandler
{
    private readonly MainWindow _owner;

    public WindowMessageHandler(MainWindow owner)
    {
        _owner = owner;
    }

    public IntPtr HandleWindowMessage(IntPtr hwnd, uint msg, IntPtr wParam, IntPtr lParam)
    {
        if (msg == WM_SYSCOMMAND && wParam.ToInt32() == SC_CLOSE)
        {
            _owner.HideWindow();
            return new IntPtr(1);
        }

        if (_owner._trayIcon != null && msg == _owner._trayIcon.CallbackMessage)
        {
            var param = lParam.ToInt32();
            if (param == WM_RBUTTONUP)
            {
                _owner._trayIcon.ShowContextMenu();
                return new IntPtr(1);
            }
            if (param == WM_LBUTTONUP)
            {
                _owner.ToggleVisibility();
                return new IntPtr(1);
            }
        }

        if (_owner._hotKey != null && _owner._hotKey.HandleMessage(msg, wParam, lParam))
        {
            return new IntPtr(1);
        }

        return IntPtr.Zero;
    }
}
```

#### Step 4: Use service helpers in show/hide
- [ ] Replace direct calls to `WindowsApi.ShowWindow` / `SetForegroundWindow` with service equivalents:

```csharp
_nativeWindowService.RestoreWindow(_windowHandle);
_nativeWindowService.FocusWindow(_windowHandle);
```

- [ ] Update `HideWindow` to call `_nativeWindowService.HideWindow(_windowHandle);`

#### Step 5: Dispose subclass service
- [ ] In `OnClosed`, call `_subclassService.Detach();`
- [ ] Implement `IDisposable` on `MainWindow` or override `OnClosed` to dispose `_subclassService` (already detaching is enough because service implements `IDisposable`).

## Verification Checklist

- [ ] `MainWindow.xaml.cs` no longer contains nested `WindowMessageBridge`/`WinApiSubClass`
- [ ] `dotnet build ResizeMe.sln` passes
- [ ] Hotkey + tray clicks still route through handler when running locally

## Troubleshooting

| Issue | Solution |
|-------|----------|
| Tray/hotkey events stop firing | Ensure `WindowMessageHandler` returns non-zero result to swallow the message; returning `IntPtr.Zero` lets Win32 continue processing. |
| `AttachAsync` throws `HWND must be valid` | Verify `EnsureWindowHandle` is called before `AttachSubclass`. |
| `NullReferenceException` in `WindowMessageHandler` | Confirm `_trayIcon` or `_hotKey` exist before using; code above already null-checks. |

## Files Modified

- [ ] ✅ Updated: `ResizeMe/MainWindow.xaml.cs`

## What Comes Next

- Proceed to Step 2 (Tray extraction) once Step 1 passes build validation.
