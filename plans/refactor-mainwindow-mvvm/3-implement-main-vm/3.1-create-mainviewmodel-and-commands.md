# Step 3.1: Create MainViewModel and Commands

**Part of:** Step 3 from plan.md  
**Focus:** Introduce `MainViewModel` to hold presets, window snapshot, and command logic  
**Files to Create/Edit:** `ResizeMe/ViewModels/MainViewModel.cs`, `ResizeMe/ViewModels/ViewModelBase.cs`  
**Estimated Time:** 20 minutes

## Overview

The ViewModel isolates state and logic currently stored directly on `MainWindow`. It loads presets, exposes observable collections, and surfaces commands for resize, settings, and toggles.

## Pre-Substep Checklist

- [ ] **Branch:** `refactor/mainwindow-mvvm`
- [ ] **Current Step:** Steps 1 & 2 complete
- [ ] **Codebase State:** `dotnet build ResizeMe.sln`

## Implementation

### Goal
Create a reusable MVVM foundation with `INotifyPropertyChanged`, then implement `MainViewModel` that orchestrates preset loading, window discovery, and resizing via injected services.

### Step-by-Step Instructions

#### Step 1: Create ViewModel base
- [ ] Add folder `ResizeMe/ViewModels/`
- [ ] Create `ViewModelBase.cs` with INotifyPropertyChanged implementation:

```csharp
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace ResizeMe.ViewModels
{
    public abstract class ViewModelBase : INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler? PropertyChanged;

        protected bool SetProperty<T>(ref T field, T value, [CallerMemberName] string? propertyName = null)
        {
            if (EqualityComparer<T>.Default.Equals(field, value))
            {
                return false;
            }

            field = value;
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
            return true;
        }
    }
}
```

#### Step 2: Implement MainViewModel
- [ ] Create `ResizeMe/ViewModels/MainViewModel.cs`
- [ ] Paste the following implementation (adjust namespaces to reuse existing services):

```csharp
using System;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.UI.Dispatching;
using ResizeMe.Features.MainLayout;
using ResizeMe.Features.WindowManagement;
using ResizeMe.Models;
using ResizeMe.Shared.Config;
using ResizeMe.Shared.Logging;

namespace ResizeMe.ViewModels
{
    public sealed class MainViewModel : ViewModelBase
    {
        private readonly PresetStorage _presets;
        private readonly WindowDiscoveryService _windowDiscovery;
        private readonly WindowResizeService _windowResizer;
        private readonly DispatcherQueue _dispatcherQueue;
        private readonly string _logger = nameof(MainViewModel);

        private bool _isVisible;
        private bool _centerOnResize;
        private WindowInfo? _selectedWindow;
        private string? _status;
        private ObservableCollection<PresetSize> _presetCollection = new();

        public ObservableCollection<PresetSize> Presets
        {
            get => _presetCollection;
            private set => SetProperty(ref _presetCollection, value);
        }

        public bool IsVisible
        {
            get => _isVisible;
            private set => SetProperty(ref _isVisible, value);
        }

        public bool CenterOnResize
        {
            get => _centerOnResize;
            set
            {
                if (SetProperty(ref _centerOnResize, value))
                {
                    UserSettingsStore.CenterOnResize = value;
                }
            }
        }

        public WindowInfo? SelectedWindow
        {
            get => _selectedWindow;
            private set => SetProperty(ref _selectedWindow, value);
        }

        public string? Status
        {
            get => _status;
            private set => SetProperty(ref _status, value);
        }

        public MainViewModel(
            DispatcherQueue dispatcherQueue,
            PresetStorage presets,
            WindowDiscoveryService windowDiscovery,
            WindowResizeService windowResizer)
        {
            _dispatcherQueue = dispatcherQueue;
            _presets = presets;
            _windowDiscovery = windowDiscovery;
            _windowResizer = windowResizer;
            _centerOnResize = UserSettingsStore.CenterOnResize;
        }

        public async Task InitializeAsync()
        {
            await _presets.LoadAsync();
            RefreshPresetCollection();
            RefreshWindowSnapshot();
        }

        public void RefreshWindowSnapshot()
        {
            var windows = _windowDiscovery.GetWindows().ToList();
            SelectedWindow = _windowDiscovery.GetActiveWindow() ?? windows.FirstOrDefault();
        }

        public async Task ReloadPresetsAsync()
        {
            await _presets.LoadAsync(true);
            RefreshPresetCollection();
        }

        public async Task ResizeSelectedWindowAsync(PresetSize preset)
        {
            if (preset == null)
            {
                return;
            }

            var target = SelectedWindow;
            if (target == null)
            {
                Status = "No window";
                return;
            }

            Status = $"Resizing {preset.Tag}...";
            var result = _windowResizer.Resize(target, preset.Width, preset.Height);
            if (result.Success)
            {
                if (CenterOnResize)
                {
                    WindowPositionService.CenterExternalWindow(target);
                }
                _windowResizer.Activate(target);
                Status = $"Done {preset.Tag}";
                await Task.Delay(500);
                _dispatcherQueue.TryEnqueue(() => IsVisible = false);
            }
            else
            {
                Status = result.ErrorMessage ?? "Resize failed";
                AppLog.Warn(_logger, Status);
            }
        }

        public void Show()
        {
            IsVisible = true;
            RefreshWindowSnapshot();
        }

        public void Hide()
        {
            IsVisible = false;
        }

        private void RefreshPresetCollection()
        {
            _dispatcherQueue.TryEnqueue(() =>
            {
                Presets = new ObservableCollection<PresetSize>(_presets.Presets);
            });
        }
    }
}
```

## Verification Checklist

- [ ] ViewModel files compile
- [ ] No warnings about missing namespaces or assemblies

## Troubleshooting

| Issue | Solution |
|-------|----------|
| `DispatcherQueue` null | Pass `DispatcherQueue.GetForCurrentThread()` from `MainWindow` when instantiating `MainViewModel`. |
| Duplicate namespace errors | Ensure files live under `ResizeMe/ViewModels` and namespaces match. |
| Presets not updating | Confirm `RefreshPresetCollection` uses dispatcher to assign `ObservableCollection`. |

## Files Modified

- [ ] ✅ Created: `ResizeMe/ViewModels/ViewModelBase.cs`
- [ ] ✅ Created: `ResizeMe/ViewModels/MainViewModel.cs`

## What Comes Next

- Step 3.2 will bind `MainWindow` to `MainViewModel` and remove duplicated state fields.
