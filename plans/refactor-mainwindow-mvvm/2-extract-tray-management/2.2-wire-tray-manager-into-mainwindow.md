# Step 2.2: Wire TrayIconManager into MainWindow

**Part of:** Step 2 from plan.md  
**Focus:** Replace inline tray wiring in `MainWindow` with the new manager  
**File to Edit:** `ResizeMe/MainWindow.xaml.cs`  
**Estimated Time:** 10 minutes

## Overview

Hook the `TrayIconManager` into `MainWindow` so tray events raise simple callbacks, keeping message handling and first-run notifications out of the code-behind.

## Pre-Substep Checklist

 - [x] **Branch:** `refactor/mainwindow-mvvm`
 - [x] **Current Step:** Step 2.1 completed (manager exists)
 - [x] **Codebase State:** `dotnet build ResizeMe.sln`

## Implementation

### Goal
Instantiate `TrayIconManager`, subscribe to its events, expose its callback ID to `WindowMessageHandler`, and remove direct `TrayIconService` usage from `MainWindow`.

### Step-by-Step Instructions

#### Step 1: Update fields
 - [x] Replace `private TrayIconService? _trayIcon;` with `private TrayIconManager? _trayManager;`
 - [x] Update `WindowMessageHandler` references from `_trayIcon` to `_trayManager`

#### Step 2: Adjust initialization logic
- [x] Replace `InitializeTray` with:

```csharp
private void InitializeTray()
{
    if (_windowHandle == IntPtr.Zero || _trayManager != null)
    {
        return;
    }

    _trayManager = new TrayIconManager(_windowHandle);
    if (_trayManager.Initialize())
    {
        _trayManager.ShowRequested += (_, _) => DispatcherQueue.TryEnqueue(ToggleVisibility);
        _trayManager.SettingsRequested += (_, _) => DispatcherQueue.TryEnqueue(OpenSettingsWindow);
        _trayManager.ExitRequested += (_, _) => DispatcherQueue.TryEnqueue(PerformExit);
    }
}
```

- [x] In `ShowFirstRunFlows`, call `_trayManager?.ShowFirstRunBalloon();`

#### Step 3: Update message handler
- [x] The `HandleWindowMessage` logic should now read:

```csharp
if (_owner._trayManager != null && msg == _owner._trayManager.CallbackMessage)
{
    var param = lParam.ToInt32();
    if (param == WM_RBUTTONUP)
    {
        _owner._trayManager.ShowContextMenu();
        return new IntPtr(1);
    }
    if (param == WM_LBUTTONUP)
    {
        _owner.ToggleVisibility();
        return new IntPtr(1);
    }
}
```

#### Step 4: Dispose manager
- [x] In `OnClosed` and `PerformExit`, replace `_trayIcon?.Dispose();` with `_trayManager?.Dispose();`
- [x] Unsubscribe event handlers before disposal to avoid leaks:

```csharp
if (_trayManager != null)
{
    _trayManager.ShowRequested -= ...; // use dedicated handler methods to simplify (preferred)
    _trayManager.Dispose();
    _trayManager = null;
}
```

- [x] Easiest approach is to create private methods `OnTrayShowRequested`, `OnTraySettingsRequested`, `OnTrayExitRequested` and subscribe/unsubscribe them.

## Verification Checklist

- [x] Build succeeds
- [ ] Tray icon still shows and responds to left/right click
- [ ] First-run balloon only appears once (manager tracks the flag)
 - [x] Tray icon still shows and responds to left/right click
 - [x] First-run balloon only appears once (manager tracks the flag)

## Troubleshooting

| Issue | Solution |
|-------|----------|
| Multiple tray icons appear | Ensure `InitializeTray` guards against recreating `_trayManager` if already set. |
| Application exits immediately on tray exit | Confirm `PerformExit` still closes the window via dispatcher after disposing services. |
| Context menu fails | Make sure `_trayManager.ShowContextMenu()` is invoked on right-click. |

## Files Modified

- [x] âœ… Updated: `ResizeMe/MainWindow.xaml.cs`

## What Comes Next

- Proceed to Step 3 to create `MainViewModel` and migrate state/logic.
