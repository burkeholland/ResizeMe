# Step 1.2: Minimize-To-Tray Behavior & WndProc Integration

**Part of:** Step 1 from plan.md  
**Focus:** Intercept tray icon messages, show context menu, and convert window close (X) into hide-to-tray.  
**File to Edit:** `ResizeMe/MainWindow.xaml.cs`  
**Estimated Time:** 12 minutes

## Overview
Adds message handling for tray callback, invokes context menu on right-click, and intercepts the system close command to hide the window instead of exiting. Exit is performed only through tray menu “Exit”.

## Pre-Substep Checklist

- [ ] **Branch:** `system-tray-integration`
- [ ] **Prior Substep:** 1.1 completed (TrayIconManager updated)
- [ ] **Build OK:** `dotnet build ResizeMe.sln`

## Implementation

### Goal
Enable interactive tray behavior and minimize-on-close UX without terminating the application.

### Step-by-Step Instructions

#### Step 1: Update Fields & Constants
- [ ] Open `ResizeMe/MainWindow.xaml.cs`
- [ ] Add constants for messages & system command

```csharp
// Add near other private fields inside MainWindow class:
private const int WM_SYSCOMMAND = 0x0112;
private const int SC_CLOSE = 0xF060;
private const int WM_COMMAND = 0x0111;
private const int WM_RBUTTONUP = 0x0205; // For potential direct mouse detection if needed
```

#### Step 2: Subscribe to Tray Events After Initialization
- [ ] In `EnsureHotKeyRegistration()` after tray initialization, subscribe to events:

```csharp
if (_trayIcon == null && _windowHandle != IntPtr.Zero)
{
    _trayIcon = new TrayIconManager(_windowHandle);
    if (_trayIcon.Initialize())
    {
        _trayIcon.ShowRequested += (_, _) => DispatcherQueue.TryEnqueue(ToggleVisibility);
        _trayIcon.SettingsRequested += (_, _) => DispatcherQueue.TryEnqueue(OpenSettingsWindow);
        _trayIcon.ExitRequested += (_, _) => DispatcherQueue.TryEnqueue(PerformExit);
    }
}
```

Add helper methods inside `MainWindow`:

```csharp
private void OpenSettingsWindow()
{
    try
    {
        var win = new SettingsWindow();
        win.PresetsChanged += OnSettingsPresetsChanged;
        win.Closed += async (_, _) =>
        {
            win.PresetsChanged -= OnSettingsPresetsChanged;
            await _presetManager.LoadAsync(true);
            DispatcherQueue.TryEnqueue(LoadPresetButtons);
        };
        win.Activate();
        StatusText.Text = "Settings opened";
    }
    catch (Exception ex)
    {
        StatusText.Text = "Settings failed";
        System.Diagnostics.Debug.WriteLine($"Settings open error: {ex.Message}");
    }
}

private void PerformExit()
{
    try
    {
        _trayIcon?.Dispose();
        _hotKeyManager?.Dispose();
        Close(); // Actual window close
    }
    catch (Exception ex)
    {
        System.Diagnostics.Debug.WriteLine($"Exit error: {ex.Message}");
    }
}
```

#### Step 3: Intercept Tray Callback & System Commands in WndProc
- [ ] Modify `WndProcSubClass` to process tray callback message and system close:

```csharp
private IntPtr WndProcSubClass(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam, IntPtr uIdSubclass, IntPtr dwRefData)
{
    // Handle system close -> hide to tray instead of closing
    if (uMsg == WM_SYSCOMMAND && wParam.ToInt32() == SC_CLOSE)
    {
        HideWindow();
        return IntPtr.Zero; // Swallow default close
    }

    // Tray icon callback dispatch
    if (_trayIcon != null && uMsg == _trayIcon.TrayCallbackMessage)
    {
        // LOWORD(lParam) contains mouse event; we invoke menu on right-button release
        int lParamVal = lParam.ToInt32();
        if (lParamVal == WM_RBUTTONUP)
        {
            _trayIcon.ShowContextMenu();
            return IntPtr.Zero;
        }
        // Left click toggles show/hide for convenience
        if (lParamVal == 0x0202) // WM_LBUTTONUP
        {
            ToggleVisibility();
            return IntPtr.Zero;
        }
    }

    // Existing hotkey handling
    if (_hotKeyManager?.ProcessMessage(uMsg, wParam, lParam) == true)
        return IntPtr.Zero;

    return WinApiSubClass.DefSubclassProc(hWnd, uMsg, wParam, lParam);
}
```

#### Step 4: Remove Previous SettingsButton_Click if Desired (Optional)
- [ ] You may keep original `SettingsButton_Click`; the tray menu uses `OpenSettingsWindow()`.

#### Step 5: Build & Run
- [ ] Save file
- [ ] `dotnet build ResizeMe.sln`
- [ ] Run app
- [ ] Click title bar X: window should hide, process still running (verify in tray)
- [ ] Right-click tray icon: menu appears; select Exit -> app closes

## Verification Checklist

- [ ] Close button hides window (process remains)
- [ ] Right-click tray icon shows context menu
- [ ] Selecting Show/Hide toggles visibility
- [ ] Settings opens from tray
- [ ] Exit disposes tray and closes app

## Troubleshooting

| Issue | Solution |
|-------|----------|
| App exits when clicking X | Confirm SC_CLOSE branch in `WndProcSubClass` returns IntPtr.Zero after `HideWindow()` |
| Context menu not showing | Ensure `_trayIcon.ShowContextMenu()` invoked when `lParamVal == WM_RBUTTONUP` |
| Hotkey stops working | Verify hotkey handling preserved at end of WndProcSubClass |
| Left-click on tray does nothing | Confirm `lParamVal == 0x0202` condition; some shells may send different up code; log lParam for diagnosis |

## Files Modified

- [ ] ✅ Modified: `ResizeMe/MainWindow.xaml.cs`

## What Comes Next

- Proceed to Step 2: First-run preference & automatic Settings window display.
