# Step 1.1: Tray Context Menu

**Part of:** Step 1 from plan.md  
**Focus:** Add context menu capability to `TrayIconManager` and expose events for Show, Settings, Exit.  
**File to Edit:** `ResizeMe/Services/TrayIconManager.cs`  
**Estimated Time:** 10 minutes

## Overview
Implements a right-click context menu on the existing tray icon allowing users to Show the main window, open Settings, or Exit the application. This is foundational for minimize-to-tray behavior.

## Pre-Substep Checklist

 - [x] **Branch:** Working on `system-tray-integration`
- [ ] **Current Step:** No prior substeps depend on this one
 - [x] **Codebase State:** Project builds successfully (`dotnet build ResizeMe.sln`)

## Implementation

### Goal
Provide a Win32 tray icon context menu with three functional items and raise .NET events when selected.

### Step-by-Step Instructions

#### Step 1: Extend Interop & Constants
 - [x] Open `ResizeMe/Services/TrayIconManager.cs`
 - [x] Add command ID constants and required P/Invoke for popup menu functions
- [ ] Ensure existing struct `NOTIFYICONDATA` untouched except for reuse

```csharp
using System;
using System.Runtime.InteropServices;
using System.Diagnostics;

namespace ResizeMe.Services
{
    /// <summary>
    /// Manages system tray icon, context menu, and related events.
    /// </summary>
    public class TrayIconManager : IDisposable
    {
        private readonly IntPtr _hWnd;
        private bool _added;

        // Tray notification message id (custom WM_USER offset)
        private const int WM_USER_TRAY = 0x0400 + 500;

        // Notify icon flags
        private const int NIF_MESSAGE = 0x0001;
        private const int NIF_ICON = 0x0002;
        private const int NIF_TIP = 0x0004;
        private const int NIM_ADD = 0x00000000;
        private const int NIM_DELETE = 0x00000002;

        // Menu item command IDs
        private const int CMD_SHOW = 10001;
        private const int CMD_SETTINGS = 10002;
        private const int CMD_EXIT = 10003;

        // TrackPopupMenu flags
        private const uint TPM_RIGHTBUTTON = 0x0002;
        private const uint TPM_RETURNCMD = 0x0100;

        // Win32 constants for SetForegroundWindow retry
        [DllImport("user32.dll")]
        private static extern bool SetForegroundWindow(IntPtr hWnd);

        [DllImport("user32.dll", CharSet = CharSet.Unicode)]
        private static extern IntPtr CreatePopupMenu();

        [DllImport("user32.dll", CharSet = CharSet.Unicode)]
        private static extern bool DestroyMenu(IntPtr hMenu);

        [DllImport("user32.dll", CharSet = CharSet.Unicode)]
        private static extern bool AppendMenu(IntPtr hMenu, uint uFlags, uint uIDNewItem, string lpNewItem);

        [DllImport("user32.dll", CharSet = CharSet.Unicode)]
        private static extern uint TrackPopupMenuEx(IntPtr hMenu, uint uFlags, int x, int y, IntPtr hWnd, IntPtr lpTpm);

        [DllImport("user32.dll")] private static extern bool GetCursorPos(out POINT lpPoint);

        [StructLayout(LayoutKind.Sequential)]
        private struct POINT { public int X; public int Y; }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        private struct NOTIFYICONDATA
        {
            public int cbSize;
            public IntPtr hWnd;
            public int uID;
            public int uFlags;
            public int uCallbackMessage;
            public IntPtr hIcon;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
            public string szTip;
        }

        [DllImport("shell32.dll", CharSet = CharSet.Unicode)]
        private static extern bool Shell_NotifyIcon(int dwMessage, ref NOTIFYICONDATA lpdata);

        [DllImport("user32.dll")] private static extern IntPtr LoadIcon(IntPtr hInstance, IntPtr lpIconName);

        /// <summary>Raised when user requests showing the main window.</summary>
        public event EventHandler? ShowRequested;
        /// <summary>Raised when user requests opening settings.</summary>
        public event EventHandler? SettingsRequested;
        /// <summary>Raised when user requests exiting the application.</summary>
        public event EventHandler? ExitRequested;

        public TrayIconManager(IntPtr hWnd) => _hWnd = hWnd;

        /// <summary>
        /// Creates the tray icon.
        /// </summary>
        public bool Initialize()
        {
            if (_added) return true;
            var data = new NOTIFYICONDATA
            {
                cbSize = Marshal.SizeOf<NOTIFYICONDATA>(),
                hWnd = _hWnd,
                uID = 1,
                uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP,
                uCallbackMessage = WM_USER_TRAY,
                hIcon = LoadIcon(IntPtr.Zero, new IntPtr(32512)), // IDI_APPLICATION
                szTip = "ResizeMe"
            };
            _added = Shell_NotifyIcon(NIM_ADD, ref data);
            if (!_added) Debug.WriteLine("TrayIconManager: Failed to add tray icon");
            return _added;
        }

        /// <summary>
        /// Shows the context menu at current cursor position and fires selection events.
        /// </summary>
        public void ShowContextMenu()
        {
            if (_hWnd == IntPtr.Zero) return;
            try
            {
                // Ensure window is foreground so menu dismiss behaves correctly.
                SetForegroundWindow(_hWnd);
                IntPtr hMenu = CreatePopupMenu();
                if (hMenu == IntPtr.Zero) return;

                AppendMenu(hMenu, 0, CMD_SHOW, "Show/Hide");
                AppendMenu(hMenu, 0, CMD_SETTINGS, "Settings...");
                AppendMenu(hMenu, 0, CMD_EXIT, "Exit");

                GetCursorPos(out var pt);
                uint cmd = TrackPopupMenuEx(hMenu, TPM_RIGHTBUTTON | TPM_RETURNCMD, pt.X, pt.Y, _hWnd, IntPtr.Zero);
                DestroyMenu(hMenu);

                if (cmd == CMD_SHOW) ShowRequested?.Invoke(this, EventArgs.Empty);
                else if (cmd == CMD_SETTINGS) SettingsRequested?.Invoke(this, EventArgs.Empty);
                else if (cmd == CMD_EXIT) ExitRequested?.Invoke(this, EventArgs.Empty);
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"TrayIconManager: Context menu error {ex.Message}");
            }
        }

        /// <summary>Tray callback message identifier for external WndProc processing.</summary>
        public int TrayCallbackMessage => WM_USER_TRAY;

        public void Dispose()
        {
            if (!_added) return;
            var data = new NOTIFYICONDATA
            {
                cbSize = Marshal.SizeOf<NOTIFYICONDATA>(),
                hWnd = _hWnd,
                uID = 1
            };
            Shell_NotifyIcon(NIM_DELETE, ref data);
            _added = false;
        }
    }
}
```

#### Step 2: Build & Verify
 - [x] Save file
 - [x] Run build: `dotnet build ResizeMe.sln`
 - [x] Confirm no compile errors

#### Step 3: (Manual Runtime Check - after Step 1.2 integration)
- Right-click tray icon should open menu (will require WndProc hook from next substep).

## Verification Checklist

 - [x] File saved in correct location: `ResizeMe/Services/TrayIconManager.cs`
 - [x] No build errors: `dotnet build ResizeMe.sln`
 - [x] Events exposed: `ShowRequested`, `SettingsRequested`, `ExitRequested`
 - [x] `ShowContextMenu()` constructs menu and tracks selection

## Troubleshooting

| Issue | Solution |
|-------|----------|
| Build error: P/Invoke signature mismatch | Ensure CharSet=Unicode and parameter types match snippet |
| Menu does not appear | Confirm WndProc hook invokes `ShowContextMenu()` (implemented next substep) |
| Events not firing | Verify returned `cmd` matches constants and not zero |
| Tray icon disappears | Ensure `Dispose()` only called on real exit (avoid premature calls) |

## Files Modified

- [x] âœ… Modified: `ResizeMe/Services/TrayIconManager.cs`

## What Comes Next

- Next substep: Step 1.2 - Minimize-to-tray behavior & WndProc integration.
