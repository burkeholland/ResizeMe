# Step 4.2: Hotkey Customization UI & Reserved Validation

**Part of:** Step 4 from plan.md  
**Focus:** Add UI in `SettingsWindow` to display current hotkey, capture new combination, validate against reserved list, and persist/update registration.  
**Files to Edit:** `ResizeMe/SettingsWindow.xaml`, `ResizeMe/SettingsWindow.xaml.cs`, `ResizeMe/Native/WindowsApi.cs`, `ResizeMe/Services/HotKeyManager.cs`  
**Estimated Time:** 25 minutes

## Overview
Enhances Settings UI with a section showing the current global hotkey and a "Customize Hotkey" workflow. Users press desired combination; reserved/system hotkeys are rejected with a clear message.

## Pre-Substep Checklist

- [x] **Branch:** `system-tray-integration`
- [x] **Prior Substeps:** 4.1 complete (dynamic registration), Steps 1–3 complete
- [x] **Build OK:** `dotnet build ResizeMe.sln`

## Implementation

### Goal
Provide a safe, user-friendly mechanism to update the global hotkey while preventing reserved system combinations.

### Step-by-Step Instructions

#### Step 1: Add Reserved Hotkey Validation Helper
- [x] Open `ResizeMe/Services/HotKeyManager.cs`
- [x] Add static reserved list and validation method near top (inside class):

```csharp
private static readonly HashSet<string> ReservedHotkeys = new(StringComparer.OrdinalIgnoreCase)
{
    "ALT+TAB", "ALT+F4", "CTRL+ALT+DELETE", "WIN+D", "WIN+L", "WIN+R", "WIN+E", "WIN+V", "WIN+M", "WIN+SHIFT+S"
};

public static bool IsReserved(string modifiers, string key)
{
    var normalized = Normalize(modifiers, key);
    return ReservedHotkeys.Contains(normalized);
}

private static string Normalize(string modifiers, string key)
{
    var order = new[] { "CTRL", "ALT", "SHIFT", "WIN" };
    var parts = modifiers.Split('+', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
                         .Select(p => p.ToUpperInvariant())
                         .Where(p => order.Contains(p))
                         .Distinct()
                         .OrderBy(p => Array.IndexOf(order, p));
    string k = key.ToUpperInvariant();
    return string.Join("+", parts.Append(k));
}
```

#### Step 2: Add Re-Registration Method
- [x] In `HotKeyManager` add:

```csharp
public bool ReRegister()
{
    if (_isRegistered) UnregisterHotKey();
    return RegisterHotKey();
}
```

#### Step 3: Settings UI Section
- [x] Open `ResizeMe/SettingsWindow.xaml`
- [x] Inside right column StackPanel (after Add New Preset card), before closing StackPanel, add hotkey section:

```xml
<!-- Hotkey Customization Card -->
<Border
  Background="{ThemeResource CardBackgroundFillColorDefaultBrush}"
  CornerRadius="8"
  BorderThickness="1"
  BorderBrush="{ThemeResource CardStrokeColorDefaultBrush}"
  Padding="16"
  Margin="0,24,0,0">
  <StackPanel Spacing="12">
    <TextBlock Text="Global Hotkey" FontWeight="SemiBold" FontSize="16" />
    <TextBlock x:Name="CurrentHotkeyText" FontSize="13" />
    <StackPanel Orientation="Horizontal" Spacing="12">
      <Button x:Name="CustomizeHotkeyButton" Content="Customize Hotkey"
              Click="CustomizeHotkeyButton_Click"
              Padding="16,8" />
      <Button x:Name="ResetHotkeyButton" Content="Reset Default"
              Click="ResetHotkeyButton_Click"
              Padding="16,8" />
    </StackPanel>
    <TextBlock x:Name="HotkeyStatusText" FontSize="11" Foreground="{ThemeResource TextFillColorSecondaryBrush}" TextWrapping="Wrap" />
    <TextBlock x:Name="HotkeyErrorText" FontSize="11" Foreground="{ThemeResource SystemFillColorCautionBrush}" TextWrapping="Wrap" Visibility="Collapsed" />
  </StackPanel>
</Border>
```

#### Step 4: Capture Dialog Logic
- [x] Open `ResizeMe/SettingsWindow.xaml.cs`
- [x] Add fields & load current hotkey in `OnLoaded` after presets:

```csharp
private string _capturedModifiers = string.Empty; // temp capture store
private string _capturedKey = string.Empty;       // temp capture store
private bool _capturing;

private void LoadHotkeyDisplay()
{
    CurrentHotkeyText.Text = $"Current: {UserPreferences.HotKeyModifiers}+{UserPreferences.HotKeyCode}";
}
```

Call `LoadHotkeyDisplay();` at end of `OnLoaded`.

#### Step 5: Add Customize Button Handler
[x] Implemented `CustomizeHotkeyButton_Click` in `SettingsWindow.xaml.cs` per plan

```csharp
private async void CustomizeHotkeyButton_Click(object sender, RoutedEventArgs e)
{
    HotkeyErrorText.Visibility = Visibility.Collapsed;
    _capturedModifiers = string.Empty;
    _capturedKey = string.Empty;
    _capturing = true;

    var dialog = new ContentDialog
    {
        Title = "Press Desired Hotkey",
        PrimaryButtonText = "Apply",
        CloseButtonText = "Cancel",
        DefaultButton = ContentDialogButton.Primary,
        XamlRoot = this.Content.XamlRoot,
        Content = new TextBlock { Text = "Press key combination now...", FontSize = 14 }
    };

    this.KeyDown += SettingsCapture_KeyDown;
    var result = await dialog.ShowAsync();
    this.KeyDown -= SettingsCapture_KeyDown;
    _capturing = false;

    if (result == ContentDialogResult.Primary)
    {
        if (string.IsNullOrWhiteSpace(_capturedKey))
        {
            HotkeyErrorText.Text = "No key captured.";
            HotkeyErrorText.Visibility = Visibility.Visible;
            return;
        }

        var mods = string.IsNullOrWhiteSpace(_capturedModifiers) ? "WIN+SHIFT" : _capturedModifiers; // enforce at least one
        if (Services.HotKeyManager.IsReserved(mods, _capturedKey))
        {
            HotkeyErrorText.Text = "This hotkey is reserved by Windows.";
            HotkeyErrorText.Visibility = Visibility.Visible;
            return;
        }

        UserPreferences.HotKeyModifiers = mods;
        UserPreferences.HotKeyCode = _capturedKey;

        // Re-register (obtain handle via MainWindow instance if needed; simplified here)
        TryReRegisterFromMainWindow();
        LoadHotkeyDisplay();
        HotkeyStatusText.Text = $"Updated to {mods}+{_capturedKey}";
    }
}
```

#### Step 6: Key Capture Handler

- [x] Implemented `SettingsCapture_KeyDown` and `MapKey` (basic mapping of letters/numbers/F-keys)

```csharp
private void SettingsCapture_KeyDown(object sender, KeyRoutedEventArgs e)
{
    if (!_capturing) return;
    var mods = new List<string>();
    var core = Windows.System.VirtualKey.None;

    // Modifier detection (KeyboardAccelerator does not apply; using core window state)
    var window = Microsoft.UI.Input.InputKeyboardSource.GetKeyStateForCurrentThread(Windows.System.VirtualKey.Control);
    if ((window & Microsoft.UI.Input.CoreInputDeviceTypes.Keyboard) != 0 && (Microsoft.UI.Input.InputKeyboardSource.GetKeyStateForCurrentThread(Windows.System.VirtualKey.Control) & Microsoft.UI.Input.KeyState.Down) != 0)
        mods.Add("CTRL");
    if ((Microsoft.UI.Input.InputKeyboardSource.GetKeyStateForCurrentThread(Windows.System.VirtualKey.Menu) & Microsoft.UI.Input.KeyState.Down) != 0)
        mods.Add("ALT");
    if ((Microsoft.UI.Input.InputKeyboardSource.GetKeyStateForCurrentThread(Windows.System.VirtualKey.Shift) & Microsoft.UI.Input.KeyState.Down) != 0)
        mods.Add("SHIFT");
    // Windows key detection fallback: treat meta as WIN if no API direct; approximate using typical combos
    // (Optional advanced: low-level hook). For simplicity: if none selected, assume user will include WIN manually via UI (not captured here).

    core = e.Key;
    if (core == Windows.System.VirtualKey.Control || core == Windows.System.VirtualKey.Menu || core == Windows.System.VirtualKey.Shift)
    {
        // Only modifiers pressed so far; wait for primary key.
        _capturedModifiers = string.Join("+", mods);
        return;
    }

    string keyToken = MapKey(core);
    _capturedKey = keyToken;
    _capturedModifiers = string.Join("+", mods);
    HotkeyStatusText.Text = $"Captured: {(_capturedModifiers.Length > 0 ? _capturedModifiers + "+" : string.Empty)}{_capturedKey}";
    e.Handled = true;
}

private static string MapKey(Windows.System.VirtualKey key)
{
    if (key >= Windows.System.VirtualKey.Number0 && key <= Windows.System.VirtualKey.Number9)
        return ((char)key).ToString();
    if (key >= Windows.System.VirtualKey.A && key <= Windows.System.VirtualKey.Z)
        return ((char)key).ToString();
    if (key >= Windows.System.VirtualKey.F1 && key <= Windows.System.VirtualKey.F24)
    {
        int fNum = (int)key - (int)Windows.System.VirtualKey.F1 + 1;
        return $"F{fNum}";
    }
    return key.ToString().ToUpperInvariant();
}
```

#### Step 7: Reset Button Handler

- [x] Implemented `ResetHotkeyButton_Click`

```csharp
private void ResetHotkeyButton_Click(object sender, RoutedEventArgs e)
{
    UserPreferences.HotKeyModifiers = "WIN+SHIFT";
    UserPreferences.HotKeyCode = "F12";
    TryReRegisterFromMainWindow();
    LoadHotkeyDisplay();
    HotkeyStatusText.Text = "Reset to default Win+Shift+F12";
    HotkeyErrorText.Visibility = Visibility.Collapsed;
}
```

#### Step 8: Re-Registration Bridge
- [x] Add helper (SettingsWindow.xaml.cs):

```csharp
private void TryReRegisterFromMainWindow()
{
    try
    {
        // Locate existing MainWindow (simplified for single window app)
        var main = (Application.Current as App)?.MainWindow as MainWindow;
        // If direct access is limited, consider exposing static accessor or event.
        // For this doc: assume a single instance accessible.
        var field = typeof(MainWindow).GetField("_hotKeyManager", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
        if (main != null && field?.GetValue(main) is HotKeyManager hk)
        {
            hk.ReRegister();
        }
    }
    catch (Exception ex)
    {
        HotkeyStatusText.Text = $"Re-register failed: {ex.Message}";
    }
}
```

*(Production recommendation: expose a public method on `MainWindow` to avoid reflection; reflection used here for isolated doc completeness.)*

#### Step 9: Build & Test
 - [x] Save all files
 - [x] `dotnet build ResizeMe.sln`
- [ ] Run app -> Open Settings -> Global Hotkey displays
- [ ] Click Customize -> Press combination (e.g., CTRL+ALT+R) -> Apply
- [ ] Press new hotkey -> main window toggles
- [ ] Attempt reserved (ALT+F4) -> Error message appears, no change applied
- [ ] Reset default -> Win+Shift+F12 restored

## Verification Checklist

- [ ] Current hotkey displayed accurately
- [ ] Customize workflow captures modifiers & key
- [ ] Reserved combinations blocked with clear message
- [ ] Successful change persists and hotkey works immediately
- [ ] Reset restores original default

## Troubleshooting

| Issue | Solution |
|-------|----------|
| Hotkey not updating | Confirm `ReRegister()` called; check reflection bridge or implement public method |
| WIN key not captured | Current approach cannot detect Windows key directly; advise user to include SHIFT/CTRL etc., keep WIN in default fallback; consider low-level hook for full support |
| Reserved not blocked | Verify `ReservedHotkeys` list contains normalized match (e.g., ALT+F4) |
| Dialog never captures key | Ensure `this.KeyDown += SettingsCapture_KeyDown;` set before `ShowAsync()` |
| Build errors (namespaces) | Add `using System.Collections.Generic; using System.Linq; using ResizeMe.Services;` at top of SettingsWindow.xaml.cs if missing |

## Files Modified

- [x] ✅ Modified: `ResizeMe/Services/HotKeyManager.cs`
- [x] ✅ Modified: `ResizeMe/SettingsWindow.xaml`
- [x] ✅ Modified: `ResizeMe/SettingsWindow.xaml.cs`
- [ ] ✅ (Clarified) `ResizeMe/Native/WindowsApi.cs` unchanged in this substep unless expanding key detection

## What Comes Next

- All core plan steps complete. Review entire feature set against success criteria and perform integrated testing.
