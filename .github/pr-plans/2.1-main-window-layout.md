# PR 2.1: Main Window Layout

**Branch Name:** `feature/main-window-layout`

**Description:** Create the floating context menu UI with borderless design, always-on-top behavior, and cursor-based positioning for the resize menu.

**Technology Stack:** WinUI 3, .NET 8.0, XAML, Windows App SDK 1.8

**Dependencies:** 
- PR 1.1 (Global Hotkey Registration) - uses hotkey trigger system
- PR 1.2 (Window Enumeration) - will display discovered windows
- PR 1.3 (Window Resizing Logic) - will connect resize actions

**Part of Phase:** Phase 2: UI Layer - Main Window - creates the primary user interface for window selection and resizing

## Pre-Implementation Checklist

- [ ] **Branch Creation:** If not already on the main/default branch, run:
   ```powershell
   cd x:\burkeholland\ResizeMe
   git checkout main
   git pull
   git checkout -b feature/main-window-layout
   ```

- [ ] **Verify Project Setup:** Ensure the project builds/runs successfully
   ```powershell
   dotnet build
   ```
   Expected output: Build succeeded with no errors or warnings

## Implementation Steps

### Step 1: Create Floating Menu Window XAML Layout

**Goal:** Design a modern, floating context menu UI with preset size buttons and proper visual hierarchy

**File to Edit:** `ResizeMe/MainWindow.xaml`

**Checklist:**
- [ ] Open existing MainWindow.xaml file
- [ ] Replace the entire content with the new floating menu design
- [ ] Copy and paste the entire content below:

```xml
<?xml version="1.0" encoding="utf-8"?>
<Window
    x:Class="ResizeMe.MainWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:ResizeMe"
    Title="ResizeMe"
    Width="280" Height="400"
    MinWidth="280" MinHeight="300"
    MaxWidth="350" MaxHeight="600"
    WindowState="Normal"
    Activated="Window_Activated"
    Deactivated="Window_Deactivated"
    Closed="Window_Closed">

    <!-- Custom title bar to remove default window chrome -->
    <Window.SystemBackdrop>
        <MicaBackdrop Kind="BaseAlt"/>
    </Window.SystemBackdrop>

    <Grid x:Name="RootGrid" Background="{ThemeResource CardBackgroundFillColorDefaultBrush}"
          CornerRadius="8" BorderThickness="1" 
          BorderBrush="{ThemeResource CardStrokeColorDefaultBrush}">
        
        <!-- Drop shadow effect -->
        <Grid.Shadow>
            <ThemeShadow />
        </Grid.Shadow>

        <Grid.RowDefinitions>
            <!-- Title bar area -->
            <RowDefinition Height="48"/>
            <!-- Content area -->
            <RowDefinition Height="*"/>
            <!-- Footer area -->
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <!-- Custom Title Bar -->
        <Grid x:Name="TitleBar" Grid.Row="0" Background="Transparent" Margin="16,8,16,8">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="*"/>
                <ColumnDefinition Width="Auto"/>
                <ColumnDefinition Width="Auto"/>
            </Grid.ColumnDefinitions>

            <!-- App title and info -->
            <StackPanel Grid.Column="0" Orientation="Horizontal" VerticalAlignment="Center">
                <FontIcon FontFamily="Segoe Fluent Icons" Glyph="&#xE8B9;" 
                         FontSize="16" Foreground="{ThemeResource AccentAAFillColorDefaultBrush}" 
                         Margin="0,0,8,0"/>
                <TextBlock Text="ResizeMe" FontWeight="SemiBold" FontSize="14" 
                          VerticalAlignment="Center" Foreground="{ThemeResource TextFillColorPrimaryBrush}"/>
            </StackPanel>

            <!-- Window state indicator -->
            <TextBlock x:Name="StatusText" Grid.Column="1" Text="Ready" FontSize="12" 
                      VerticalAlignment="Center" HorizontalAlignment="Center"
                      Foreground="{ThemeResource TextFillColorSecondaryBrush}" 
                      Margin="8,0"/>

            <!-- Settings button -->
            <Button x:Name="SettingsButton" Grid.Column="2" Style="{ThemeResource SubtleButtonStyle}"
                   Width="32" Height="32" Padding="4" ToolTipService.ToolTip="Settings"
                   Click="SettingsButton_Click">
                <FontIcon FontFamily="Segoe Fluent Icons" Glyph="&#xE713;" FontSize="14"/>
            </Button>
        </Grid>

        <!-- Main Content Area -->
        <ScrollViewer x:Name="ContentScrollViewer" Grid.Row="1" Margin="16,8,16,16" 
                     VerticalScrollBarVisibility="Auto" HorizontalScrollBarVisibility="Disabled">
            
            <StackPanel x:Name="MainContent" Spacing="16">
                
                <!-- Current Window Info Section -->
                <Border x:Name="CurrentWindowSection" Background="{ThemeResource ControlFillColorDefaultBrush}" 
                       CornerRadius="6" Padding="12" Visibility="Collapsed">
                    <StackPanel Spacing="8">
                        <TextBlock Text="Target Window" FontWeight="SemiBold" FontSize="12" 
                                  Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
                        <TextBlock x:Name="CurrentWindowText" Text="No window selected" FontSize="14" 
                                  TextWrapping="WrapWholeWords" Foreground="{ThemeResource TextFillColorPrimaryBrush}"/>
                        <TextBlock x:Name="CurrentWindowSize" Text="" FontSize="12" 
                                  Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
                    </StackPanel>
                </Border>

                <!-- Quick Resize Presets Section -->
                <StackPanel x:Name="PresetsSection" Spacing="12">
                    <TextBlock Text="Quick Resize" FontWeight="SemiBold" FontSize="16" 
                              Foreground="{ThemeResource TextFillColorPrimaryBrush}"/>
                    
                    <!-- Common presets in a responsive grid -->
                    <Grid x:Name="PresetsGrid">
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto"/>
                            <RowDefinition Height="Auto"/>
                            <RowDefinition Height="Auto"/>
                            <RowDefinition Height="Auto"/>
                        </Grid.RowDefinitions>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="*"/>
                            <ColumnDefinition Width="*"/>
                        </Grid.ColumnDefinitions>

                        <!-- Row 1: HD and Full HD -->
                        <Button x:Name="Preset1280x720" Grid.Row="0" Grid.Column="0" 
                               Style="{ThemeResource AccentButtonStyle}" Margin="0,0,4,4"
                               Height="48" Click="PresetButton_Click" Tag="1280x720">
                            <StackPanel Orientation="Vertical" Spacing="2">
                                <TextBlock Text="HD" FontWeight="SemiBold" FontSize="14"/>
                                <TextBlock Text="1280×720" FontSize="11" Opacity="0.9"/>
                            </StackPanel>
                        </Button>

                        <Button x:Name="Preset1920x1080" Grid.Row="0" Grid.Column="1" 
                               Style="{ThemeResource DefaultButtonStyle}" Margin="4,0,0,4"
                               Height="48" Click="PresetButton_Click" Tag="1920x1080">
                            <StackPanel Orientation="Vertical" Spacing="2">
                                <TextBlock Text="Full HD" FontWeight="SemiBold" FontSize="14"/>
                                <TextBlock Text="1920×1080" FontSize="11" Opacity="0.7"/>
                            </StackPanel>
                        </Button>

                        <!-- Row 2: Common laptop sizes -->
                        <Button x:Name="Preset1366x768" Grid.Row="1" Grid.Column="0" 
                               Style="{ThemeResource DefaultButtonStyle}" Margin="0,4,4,4"
                               Height="48" Click="PresetButton_Click" Tag="1366x768">
                            <StackPanel Orientation="Vertical" Spacing="2">
                                <TextBlock Text="Laptop" FontWeight="SemiBold" FontSize="14"/>
                                <TextBlock Text="1366×768" FontSize="11" Opacity="0.7"/>
                            </StackPanel>
                        </Button>

                        <Button x:Name="Preset1024x768" Grid.Row="1" Grid.Column="1" 
                               Style="{ThemeResource DefaultButtonStyle}" Margin="4,4,0,4"
                               Height="48" Click="PresetButton_Click" Tag="1024x768">
                            <StackPanel Orientation="Vertical" Spacing="2">
                                <TextBlock Text="Classic" FontWeight="SemiBold" FontSize="14"/>
                                <TextBlock Text="1024×768" FontSize="11" Opacity="0.7"/>
                            </StackPanel>
                        </Button>

                        <!-- Row 3: Work sizes -->
                        <Button x:Name="Preset800x600" Grid.Row="2" Grid.Column="0" 
                               Style="{ThemeResource DefaultButtonStyle}" Margin="0,4,4,4"
                               Height="48" Click="PresetButton_Click" Tag="800x600">
                            <StackPanel Orientation="Vertical" Spacing="2">
                                <TextBlock Text="Compact" FontWeight="SemiBold" FontSize="14"/>
                                <TextBlock Text="800×600" FontSize="11" Opacity="0.7"/>
                            </StackPanel>
                        </Button>

                        <Button x:Name="Preset1440x900" Grid.Row="2" Grid.Column="1" 
                               Style="{ThemeResource DefaultButtonStyle}" Margin="4,4,0,4"
                               Height="48" Click="PresetButton_Click" Tag="1440x900">
                            <StackPanel Orientation="Vertical" Spacing="2">
                                <TextBlock Text="Work" FontWeight="SemiBold" FontSize="14"/>
                                <TextBlock Text="1440×900" FontSize="11" Opacity="0.7"/>
                            </StackPanel>
                        </Button>

                        <!-- Row 4: Custom and favorites -->
                        <Button x:Name="CustomSizeButton" Grid.Row="3" Grid.Column="0" 
                               Style="{ThemeResource DefaultButtonStyle}" Margin="0,4,4,0"
                               Height="48" Click="CustomSizeButton_Click">
                            <StackPanel Orientation="Vertical" Spacing="2">
                                <FontIcon FontFamily="Segoe Fluent Icons" Glyph="&#xE70F;" FontSize="16"/>
                                <TextBlock Text="Custom" FontWeight="SemiBold" FontSize="12"/>
                            </StackPanel>
                        </Button>

                        <Button x:Name="MorePresetsButton" Grid.Row="3" Grid.Column="1" 
                               Style="{ThemeResource DefaultButtonStyle}" Margin="4,4,0,0"
                               Height="48" Click="MorePresetsButton_Click">
                            <StackPanel Orientation="Vertical" Spacing="2">
                                <FontIcon FontFamily="Segoe Fluent Icons" Glyph="&#xE712;" FontSize="16"/>
                                <TextBlock Text="More..." FontWeight="SemiBold" FontSize="12"/>
                            </StackPanel>
                        </Button>
                    </Grid>
                </StackPanel>

                <!-- Window Selection Section -->
                <StackPanel x:Name="WindowSelectionSection" Spacing="12" Visibility="Collapsed">
                    <TextBlock Text="Select Window" FontWeight="SemiBold" FontSize="16" 
                              Foreground="{ThemeResource TextFillColorPrimaryBrush}"/>
                    
                    <ListView x:Name="WindowList" MaxHeight="200" 
                             SelectionMode="Single" SelectionChanged="WindowList_SelectionChanged"
                             Background="Transparent" BorderThickness="0">
                        <ListView.ItemTemplate>
                            <DataTemplate>
                                <Grid Margin="0,4" Padding="8" Background="{ThemeResource ControlFillColorDefaultBrush}" 
                                     CornerRadius="4">
                                    <Grid.ColumnDefinitions>
                                        <ColumnDefinition Width="Auto"/>
                                        <ColumnDefinition Width="*"/>
                                        <ColumnDefinition Width="Auto"/>
                                    </Grid.ColumnDefinitions>
                                    
                                    <FontIcon Grid.Column="0" FontFamily="Segoe Fluent Icons" Glyph="&#xE8A7;" 
                                             FontSize="16" VerticalAlignment="Center" Margin="0,0,8,0"/>
                                    
                                    <StackPanel Grid.Column="1">
                                        <TextBlock Text="{Binding DisplayText}" FontSize="14" 
                                                  TextTrimming="CharacterEllipsis" FontWeight="SemiBold"/>
                                        <TextBlock Text="{Binding Bounds}" FontSize="11" 
                                                  Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
                                    </StackPanel>
                                    
                                    <FontIcon Grid.Column="2" FontFamily="Segoe Fluent Icons" Glyph="&#xE76C;" 
                                             FontSize="12" Opacity="0.6" VerticalAlignment="Center"/>
                                </Grid>
                            </DataTemplate>
                        </ListView.ItemTemplate>
                    </ListView>
                    
                    <Button x:Name="RefreshWindowsButton" HorizontalAlignment="Stretch" 
                           Style="{ThemeResource DefaultButtonStyle}" Height="36"
                           Click="RefreshWindowsButton_Click">
                        <StackPanel Orientation="Horizontal" Spacing="8">
                            <FontIcon FontFamily="Segoe Fluent Icons" Glyph="&#xE72C;" FontSize="14"/>
                            <TextBlock Text="Refresh Window List" FontSize="14"/>
                        </StackPanel>
                    </Button>
                </StackPanel>
            </StackPanel>
        </ScrollViewer>

        <!-- Footer -->
        <Border Grid.Row="2" Background="{ThemeResource ControlFillColorDefaultBrush}" 
               CornerRadius="0,0,8,8" Padding="16,8">
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>
                
                <TextBlock x:Name="FooterText" Grid.Column="0" Text="Press Ctrl+Alt+R to show" 
                          FontSize="11" VerticalAlignment="Center" 
                          Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
                
                <StackPanel Grid.Column="1" Orientation="Horizontal" Spacing="8">
                    <Button x:Name="AlwaysOnTopButton" Style="{ThemeResource SubtleButtonStyle}"
                           Width="28" Height="28" Padding="2" ToolTipService.ToolTip="Always on top"
                           Click="AlwaysOnTopButton_Click">
                        <FontIcon FontFamily="Segoe Fluent Icons" Glyph="&#xE840;" FontSize="12"/>
                    </Button>
                    
                    <Button x:Name="HideButton" Style="{ThemeResource SubtleButtonStyle}"
                           Width="28" Height="28" Padding="2" ToolTipService.ToolTip="Hide window"
                           Click="HideButton_Click">
                        <FontIcon FontFamily="Segoe Fluent Icons" Glyph="&#xE921;" FontSize="12"/>
                    </Button>
                </StackPanel>
            </Grid>
        </Border>
    </Grid>
</Window>
```

**Verification:**
- [ ] XAML should have no syntax errors
- [ ] Visual Studio design view should show the floating menu layout
- [ ] All Grid rows and columns should be properly defined
- [ ] Button styles should resolve correctly

---

### Step 2: Create Window Positioning Helper

**Goal:** Create a utility class to handle window positioning relative to the cursor and screen bounds

**File to Create:** `ResizeMe/Helpers/WindowPositionHelper.cs`

**Checklist:**
- [ ] Create folder called "Helpers" inside ResizeMe project folder
- [ ] Right-click Helpers folder → Add → Class
- [ ] Name the new class "WindowPositionHelper.cs"
- [ ] Copy and paste the entire content below:

```csharp
using Microsoft.UI.Xaml;
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using WinRT.Interop;

namespace ResizeMe.Helpers
{
    /// <summary>
    /// Helper class for positioning windows relative to cursor and screen bounds
    /// </summary>
    public static class WindowPositionHelper
    {
        // P/Invoke declarations for cursor and screen information
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool GetCursorPos(out POINT lpPoint);

        [DllImport("user32.dll")]
        public static extern IntPtr MonitorFromPoint(POINT pt, uint dwFlags);

        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool GetMonitorInfo(IntPtr hMonitor, ref MONITORINFO lpmi);

        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int x, int y, int cx, int cy, uint uFlags);

        // Constants
        private const uint MONITOR_DEFAULTTONEAREST = 2;
        private const uint SWP_NOSIZE = 0x0001;
        private const uint SWP_NOZORDER = 0x0004;
        private const uint SWP_NOACTIVATE = 0x0010;
        private const int OFFSET_FROM_CURSOR = 20; // Pixels offset from cursor

        // Structures
        [StructLayout(LayoutKind.Sequential)]
        public struct POINT
        {
            public int X;
            public int Y;
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
        public struct MONITORINFO
        {
            public int cbSize;
            public RECT rcMonitor;
            public RECT rcWork;
            public uint dwFlags;

            public static MONITORINFO Default
            {
                get
                {
                    var mi = new MONITORINFO();
                    mi.cbSize = Marshal.SizeOf(mi);
                    return mi;
                }
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct RECT
        {
            public int Left;
            public int Top;
            public int Right;
            public int Bottom;

            public int Width => Right - Left;
            public int Height => Bottom - Top;
        }

        /// <summary>
        /// Positions a WinUI window near the cursor while keeping it within screen bounds
        /// </summary>
        /// <param name="window">The window to position</param>
        /// <param name="preferredSide">Preferred side relative to cursor (Right, Left, Below, Above)</param>
        public static void PositionNearCursor(Window window, PreferredPosition preferredSide = PreferredPosition.Right)
        {
            try
            {
                // Get cursor position
                if (!GetCursorPos(out POINT cursorPos))
                {
                    Debug.WriteLine("WindowPositionHelper: Failed to get cursor position");
                    return;
                }

                Debug.WriteLine($"WindowPositionHelper: Cursor position: {cursorPos.X}, {cursorPos.Y}");

                // Get monitor information for the cursor location
                IntPtr monitor = MonitorFromPoint(cursorPos, MONITOR_DEFAULTTONEAREST);
                var monitorInfo = MONITORINFO.Default;
                
                if (!GetMonitorInfo(monitor, ref monitorInfo))
                {
                    Debug.WriteLine("WindowPositionHelper: Failed to get monitor information");
                    return;
                }

                var workArea = monitorInfo.rcWork;
                Debug.WriteLine($"WindowPositionHelper: Work area: {workArea.Left},{workArea.Top} - {workArea.Right},{workArea.Bottom}");

                // Get window handle
                IntPtr hWnd = WindowNative.GetWindowHandle(window);
                if (hWnd == IntPtr.Zero)
                {
                    Debug.WriteLine("WindowPositionHelper: Failed to get window handle");
                    return;
                }

                // Get window dimensions
                int windowWidth = (int)window.Bounds.Width;
                int windowHeight = (int)window.Bounds.Height;

                // If bounds are not available, use default size
                if (windowWidth == 0) windowWidth = 280;
                if (windowHeight == 0) windowHeight = 400;

                // Calculate initial position based on preference
                int targetX, targetY;
                CalculateInitialPosition(cursorPos, preferredSide, windowWidth, windowHeight, out targetX, out targetY);

                // Adjust position to keep window within screen bounds
                AdjustForScreenBounds(workArea, ref targetX, ref targetY, windowWidth, windowHeight);

                Debug.WriteLine($"WindowPositionHelper: Positioning window at {targetX}, {targetY} (size: {windowWidth}x{windowHeight})");

                // Set the window position
                bool success = SetWindowPos(hWnd, IntPtr.Zero, targetX, targetY, 0, 0, 
                    SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);

                if (!success)
                {
                    Debug.WriteLine($"WindowPositionHelper: SetWindowPos failed with error {Marshal.GetLastWin32Error()}");
                }
                else
                {
                    Debug.WriteLine("WindowPositionHelper: Window positioned successfully");
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"WindowPositionHelper: Exception positioning window: {ex.Message}");
            }
        }

        /// <summary>
        /// Calculates the initial position based on cursor location and preference
        /// </summary>
        private static void CalculateInitialPosition(POINT cursorPos, PreferredPosition preference, 
            int windowWidth, int windowHeight, out int x, out int y)
        {
            switch (preference)
            {
                case PreferredPosition.Right:
                    x = cursorPos.X + OFFSET_FROM_CURSOR;
                    y = cursorPos.Y - (windowHeight / 2);
                    break;

                case PreferredPosition.Left:
                    x = cursorPos.X - windowWidth - OFFSET_FROM_CURSOR;
                    y = cursorPos.Y - (windowHeight / 2);
                    break;

                case PreferredPosition.Below:
                    x = cursorPos.X - (windowWidth / 2);
                    y = cursorPos.Y + OFFSET_FROM_CURSOR;
                    break;

                case PreferredPosition.Above:
                    x = cursorPos.X - (windowWidth / 2);
                    y = cursorPos.Y - windowHeight - OFFSET_FROM_CURSOR;
                    break;

                default:
                    x = cursorPos.X + OFFSET_FROM_CURSOR;
                    y = cursorPos.Y - (windowHeight / 2);
                    break;
            }
        }

        /// <summary>
        /// Adjusts position to ensure window stays within screen bounds
        /// </summary>
        private static void AdjustForScreenBounds(RECT workArea, ref int x, ref int y, int windowWidth, int windowHeight)
        {
            // Adjust horizontal position
            if (x < workArea.Left)
            {
                x = workArea.Left + 10; // Small margin from edge
            }
            else if (x + windowWidth > workArea.Right)
            {
                x = workArea.Right - windowWidth - 10;
            }

            // Adjust vertical position
            if (y < workArea.Top)
            {
                y = workArea.Top + 10;
            }
            else if (y + windowHeight > workArea.Bottom)
            {
                y = workArea.Bottom - windowHeight - 10;
            }
        }

        /// <summary>
        /// Centers a window on the screen
        /// </summary>
        /// <param name="window">The window to center</param>
        public static void CenterOnScreen(Window window)
        {
            try
            {
                // Get cursor position to determine which monitor
                if (!GetCursorPos(out POINT cursorPos))
                {
                    cursorPos = new POINT { X = 0, Y = 0 };
                }

                // Get monitor information
                IntPtr monitor = MonitorFromPoint(cursorPos, MONITOR_DEFAULTTONEAREST);
                var monitorInfo = MONITORINFO.Default;
                
                if (!GetMonitorInfo(monitor, ref monitorInfo))
                {
                    return;
                }

                var workArea = monitorInfo.rcWork;
                IntPtr hWnd = WindowNative.GetWindowHandle(window);
                
                if (hWnd == IntPtr.Zero) return;

                // Calculate center position
                int windowWidth = (int)window.Bounds.Width;
                int windowHeight = (int)window.Bounds.Height;

                if (windowWidth == 0) windowWidth = 280;
                if (windowHeight == 0) windowHeight = 400;

                int centerX = workArea.Left + (workArea.Width - windowWidth) / 2;
                int centerY = workArea.Top + (workArea.Height - windowHeight) / 2;

                SetWindowPos(hWnd, IntPtr.Zero, centerX, centerY, 0, 0, 
                    SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"WindowPositionHelper: Exception centering window: {ex.Message}");
            }
        }
    }

    /// <summary>
    /// Preferred position for window relative to cursor
    /// </summary>
    public enum PreferredPosition
    {
        Right,
        Left,
        Below,
        Above
    }
}
```

**Verification:**
- [ ] File should have no build errors
- [ ] All P/Invoke declarations should be correct
- [ ] WindowPositionHelper class should appear in IntelliSense
- [ ] PreferredPosition enum should be accessible

---

### Step 3: Update MainWindow Code-Behind for UI Logic

**Goal:** Implement the UI logic for the floating menu with window positioning, show/hide behavior, and preset button handling

**File to Edit:** `ResizeMe/MainWindow.xaml.cs`

**Checklist:**
- [ ] Open MainWindow.xaml.cs file
- [ ] Replace the entire file content with the new UI-focused implementation
- [ ] Copy and paste the entire content below:

```csharp
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using ResizeMe.Services;
using ResizeMe.Models;
using ResizeMe.Helpers;
using WinRT.Interop;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;

namespace ResizeMe
{
    /// <summary>
    /// Floating context menu window for ResizeMe application
    /// </summary>
    public sealed partial class MainWindow : Window
    {
        private HotKeyManager? _hotKeyManager;
        private WindowManager? _windowManager;
        private WindowResizer? _windowResizer;
        private bool _isVisible = true;
        private bool _isAlwaysOnTop = false;
        private WindowInfo? _selectedWindow;
        private List<WindowInfo> _availableWindows = new();

        public MainWindow()
        {
            this.InitializeComponent();
            
            // Initialize services
            _windowManager = new WindowManager();
            _windowResizer = new WindowResizer();
            
            // Configure window appearance
            SetupWindowAppearance();
            
            // Initialize hotkey manager after window is created
            this.Activated += MainWindow_FirstActivated;
            
            Debug.WriteLine("MainWindow: Constructor completed");
        }

        /// <summary>
        /// Sets up the window appearance and behavior
        /// </summary>
        private void SetupWindowAppearance()
        {
            try
            {
                // Set the custom title bar
                this.ExtendsContentIntoTitleBar = true;
                this.SetTitleBar(TitleBar);

                // Initially hide until hotkey is pressed
                this.WindowState = WindowState.Minimized;
                _isVisible = false;

                Debug.WriteLine("MainWindow: Window appearance configured");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"MainWindow: Error setting up appearance: {ex.Message}");
            }
        }

        /// <summary>
        /// Called when window is first activated - set up hotkey registration
        /// </summary>
        private void MainWindow_FirstActivated(object sender, WindowActivatedEventArgs args)
        {
            if (args.WindowActivationState != WindowActivationState.Deactivated && _hotKeyManager == null)
            {
                // Get the window handle for hotkey registration
                IntPtr hwnd = WindowNative.GetWindowHandle(this);
                
                if (hwnd != IntPtr.Zero)
                {
                    // Initialize and register hotkey
                    _hotKeyManager = new HotKeyManager(hwnd);
                    _hotKeyManager.HotKeyPressed += OnHotKeyPressed;
                    
                    bool success = _hotKeyManager.RegisterHotKey();
                    if (success)
                    {
                        Debug.WriteLine("MainWindow: Global hotkey Ctrl+Alt+R registered successfully");
                        StatusText.Text = "Ready";
                    }
                    else
                    {
                        Debug.WriteLine("MainWindow: Failed to register global hotkey");
                        StatusText.Text = "Hotkey failed";
                    }
                    
                    // Hook into the window's message processing
                    var subClassId = new IntPtr(1001);
                    WinApiSubClass.SetWindowSubclass(hwnd, WndProcSubClass, subClassId, IntPtr.Zero);
                }
                
                // Only need to do this once
                this.Activated -= MainWindow_FirstActivated;
                
                // Hide window after initial setup
                HideWindow();
            }
        }

        /// <summary>
        /// Handles the global hotkey press event
        /// </summary>
        private void OnHotKeyPressed(object? sender, EventArgs e)
        {
            Debug.WriteLine("MainWindow: Hotkey Ctrl+Alt+R pressed - toggling menu");
            
            if (_isVisible)
            {
                HideWindow();
            }
            else
            {
                ShowWindow();
            }
        }

        /// <summary>
        /// Shows the floating menu near the cursor
        /// </summary>
        private void ShowWindow()
        {
            try
            {
                Debug.WriteLine("MainWindow: Showing floating menu");

                // Refresh window list
                RefreshWindowList();

                // Show the window
                this.WindowState = WindowState.Normal;
                this.Activate();
                
                // Position near cursor
                WindowPositionHelper.PositionNearCursor(this, PreferredPosition.Right);
                
                _isVisible = true;
                StatusText.Text = $"Found {_availableWindows.Count} windows";

                Debug.WriteLine($"MainWindow: Menu shown with {_availableWindows.Count} windows");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"MainWindow: Error showing window: {ex.Message}");
                StatusText.Text = "Error showing";
            }
        }

        /// <summary>
        /// Hides the floating menu
        /// </summary>
        private void HideWindow()
        {
            try
            {
                Debug.WriteLine("MainWindow: Hiding floating menu");
                
                this.WindowState = WindowState.Minimized;
                _isVisible = false;
                StatusText.Text = "Hidden";
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"MainWindow: Error hiding window: {ex.Message}");
            }
        }

        /// <summary>
        /// Refreshes the list of available windows
        /// </summary>
        private void RefreshWindowList()
        {
            try
            {
                if (_windowManager != null)
                {
                    _availableWindows = _windowManager.GetResizableWindows().ToList();
                    
                    // Update UI
                    WindowList.ItemsSource = _availableWindows;
                    
                    // Show window selection if multiple windows, hide if just one
                    if (_availableWindows.Count > 1)
                    {
                        WindowSelectionSection.Visibility = Visibility.Visible;
                        CurrentWindowSection.Visibility = Visibility.Collapsed;
                    }
                    else if (_availableWindows.Count == 1)
                    {
                        WindowSelectionSection.Visibility = Visibility.Collapsed;
                        CurrentWindowSection.Visibility = Visibility.Visible;
                        
                        _selectedWindow = _availableWindows[0];
                        CurrentWindowText.Text = _selectedWindow.DisplayText;
                        CurrentWindowSize.Text = _selectedWindow.Bounds.ToString();
                    }
                    else
                    {
                        WindowSelectionSection.Visibility = Visibility.Collapsed;
                        CurrentWindowSection.Visibility = Visibility.Collapsed;
                        _selectedWindow = null;
                    }

                    Debug.WriteLine($"MainWindow: Refreshed window list - found {_availableWindows.Count} windows");
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"MainWindow: Error refreshing window list: {ex.Message}");
            }
        }

        /// <summary>
        /// Handles preset button clicks
        /// </summary>
        private async void PresetButton_Click(object sender, RoutedEventArgs e)
        {
            if (sender is Button button && button.Tag is string sizeString)
            {
                try
                {
                    // Parse size string (e.g., "1920x1080")
                    var parts = sizeString.Split('x');
                    if (parts.Length == 2 && 
                        int.TryParse(parts[0], out int width) && 
                        int.TryParse(parts[1], out int height))
                    {
                        await ResizeSelectedWindow(width, height);
                    }
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"MainWindow: Error parsing preset size: {ex.Message}");
                    StatusText.Text = "Invalid size";
                }
            }
        }

        /// <summary>
        /// Resizes the currently selected window
        /// </summary>
        private async System.Threading.Tasks.Task ResizeSelectedWindow(int width, int height)
        {
            try
            {
                var targetWindow = _selectedWindow ?? _availableWindows.FirstOrDefault();
                
                if (targetWindow == null)
                {
                    StatusText.Text = "No window selected";
                    return;
                }

                if (_windowResizer == null)
                {
                    StatusText.Text = "Resizer not available";
                    return;
                }

                Debug.WriteLine($"MainWindow: Resizing {targetWindow.DisplayText} to {width}x{height}");
                StatusText.Text = "Resizing...";

                var result = _windowResizer.ResizeWindow(targetWindow, width, height);
                
                if (result.Success)
                {
                    StatusText.Text = $"✅ Resized to {width}x{height}";
                    Debug.WriteLine($"MainWindow: ✅ {result.DisplayMessage}");
                    
                    // Activate the resized window
                    _windowResizer.ActivateWindow(targetWindow);
                    
                    // Hide the menu after successful resize
                    await System.Threading.Tasks.Task.Delay(1500); // Show success message briefly
                    HideWindow();
                }
                else
                {
                    StatusText.Text = $"❌ {result.ErrorMessage}";
                    Debug.WriteLine($"MainWindow: ❌ {result.DisplayMessage}");
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"MainWindow: Error resizing window: {ex.Message}");
                StatusText.Text = "Resize failed";
            }
        }

        // Event Handlers for UI elements

        private void Window_Activated(object sender, WindowActivatedEventArgs e)
        {
            // Update status when window gets focus
            if (_isVisible && _availableWindows.Any())
            {
                StatusText.Text = $"Found {_availableWindows.Count} windows";
            }
        }

        private void Window_Deactivated(object sender, WindowActivatedEventArgs e)
        {
            // Auto-hide when losing focus (unless always on top)
            if (_isVisible && !_isAlwaysOnTop)
            {
                HideWindow();
            }
        }

        private void Window_Closed(object sender, WindowEventArgs e)
        {
            Debug.WriteLine("MainWindow: Closing - cleaning up resources");
            _hotKeyManager?.Dispose();
        }

        private void SettingsButton_Click(object sender, RoutedEventArgs e)
        {
            StatusText.Text = "Settings (coming soon)";
            Debug.WriteLine("MainWindow: Settings button clicked");
        }

        private void WindowList_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (WindowList.SelectedItem is WindowInfo selectedWindow)
            {
                _selectedWindow = selectedWindow;
                Debug.WriteLine($"MainWindow: Selected window: {_selectedWindow.DisplayText}");
            }
        }

        private void RefreshWindowsButton_Click(object sender, RoutedEventArgs e)
        {
            RefreshWindowList();
        }

        private void CustomSizeButton_Click(object sender, RoutedEventArgs e)
        {
            StatusText.Text = "Custom size (coming soon)";
            Debug.WriteLine("MainWindow: Custom size button clicked");
        }

        private void MorePresetsButton_Click(object sender, RoutedEventArgs e)
        {
            StatusText.Text = "More presets (coming soon)";
            Debug.WriteLine("MainWindow: More presets button clicked");
        }

        private void AlwaysOnTopButton_Click(object sender, RoutedEventArgs e)
        {
            _isAlwaysOnTop = !_isAlwaysOnTop;
            StatusText.Text = _isAlwaysOnTop ? "Always on top" : "Normal mode";
            Debug.WriteLine($"MainWindow: Always on top: {_isAlwaysOnTop}");
        }

        private void HideButton_Click(object sender, RoutedEventArgs e)
        {
            HideWindow();
        }

        /// <summary>
        /// Window subclass procedure to handle Windows messages
        /// </summary>
        private IntPtr WndProcSubClass(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam, IntPtr uIdSubclass, IntPtr dwRefData)
        {
            // Let our hotkey manager process the message
            if (_hotKeyManager?.ProcessMessage(uMsg, wParam, lParam) == true)
            {
                return IntPtr.Zero; // Message handled
            }
            
            // Call default window procedure for unhandled messages
            return WinApiSubClass.DefSubclassProc(hWnd, uMsg, wParam, lParam);
        }
    }

    /// <summary>
    /// Helper class for window subclassing to handle Windows messages in WinUI
    /// </summary>
    internal static class WinApiSubClass
    {
        public delegate IntPtr SubClassProc(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam, IntPtr uIdSubclass, IntPtr dwRefData);

        [DllImport("comctl32.dll")]
        public static extern bool SetWindowSubclass(IntPtr hWnd, SubClassProc pfnSubclass, IntPtr uIdSubclass, IntPtr dwRefData);

        [DllImport("comctl32.dll")]
        public static extern IntPtr DefSubclassProc(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam);

        [DllImport("comctl32.dll")]
        public static extern bool RemoveWindowSubclass(IntPtr hWnd, SubClassProc pfnSubclass, IntPtr uIdSubclass);
    }
}
```

**Verification:**
- [ ] File should have no build errors
- [ ] All using statements should resolve correctly
- [ ] UI event handlers should be properly connected
- [ ] WindowPositionHelper should be accessible

---

## Build and Final Verification

**Checklist:**
- [ ] **Build the project:**
   ```powershell
   dotnet build
   ```
   Expected: Build succeeded with 0 errors, 0 warnings

- [ ] **Check for errors:** There should be none. If you see errors:
   - [ ] Verify MainWindow.xaml has no XAML syntax errors
   - [ ] Check that WindowPositionHelper.cs is in the Helpers folder
   - [ ] Verify all event handler method names match XAML
   - [ ] Ensure all using statements resolve correctly

- [ ] **Manual Testing:**
   - [ ] Start the application with F5 or `dotnet run`
   - [ ] Verify the app starts minimized/hidden
   - [ ] Open a test application (e.g., Notepad, Calculator)
   - [ ] Press Ctrl+Alt+R to show the floating menu
   - [ ] Verify menu appears near cursor with modern design
   - [ ] Click a preset size button (e.g., HD 1280x720)
   - [ ] Verify the target window gets resized and activated
   - [ ] Verify menu hides after successful resize
   - [ ] Test clicking outside menu to hide it

## Expected Behavior After Completion

- [ ] Application starts with hidden/minimized window
- [ ] Pressing Ctrl+Alt+R shows floating menu near cursor
- [ ] Menu has modern Fluent Design appearance with Mica backdrop
- [ ] Preset size buttons are properly laid out in a 2x4 grid
- [ ] Single window scenarios show current window info
- [ ] Multiple window scenarios show selection list
- [ ] Clicking preset buttons resizes the selected/first window
- [ ] Menu auto-hides after successful resize operation
- [ ] Menu auto-hides when clicking outside (losing focus)
- [ ] Window positioning respects screen boundaries

## Troubleshooting

| Issue | Solution |
|-------|----------|
| "Build error: Event handler not found" | Verify all Click="..." event handler names in XAML match method names in MainWindow.xaml.cs |
| "Menu doesn't appear near cursor" | Check WindowPositionHelper P/Invoke declarations and ensure GetCursorPos is working |
| "XAML design view shows errors" | Check that all ThemeResource references are valid. Some may only work at runtime |
| "Menu appears but buttons don't work" | Verify event handlers are properly connected and Tag attributes contain valid size strings |
| "Window doesn't hide automatically" | Check the Deactivated event handler and ensure _isAlwaysOnTop flag is working correctly |
| "Hotkey doesn't show menu" | Verify the hotkey registration is successful and OnHotKeyPressed method is called |
| "Modern styling doesn't appear" | Ensure you're running on Windows 10 version 19041+ with proper Windows App SDK version |

## Files Created/Modified

- [ ] ✅ Modified: `ResizeMe/MainWindow.xaml` (complete redesign for floating menu)
- [ ] ✅ Created: `ResizeMe/Helpers/WindowPositionHelper.cs`
- [ ] ✅ Modified: `ResizeMe/MainWindow.xaml.cs` (UI-focused implementation)
- [ ] ✅ No changes to: Service layer classes (WindowManager, WindowResizer, HotKeyManager)

## Commit Message Template

```
feat(ui): create floating context menu with modern design

Implements the main UI for window selection and resizing with Fluent Design.
Creates cursor-positioned floating menu with preset size buttons.

- Complete MainWindow XAML redesign with Fluent Design styling
- Add WindowPositionHelper for cursor-relative positioning
- Implement show/hide toggle behavior on global hotkey
- Create responsive preset button grid with common sizes
- Add window selection UI for multiple window scenarios
- Support auto-hide on focus loss and after successful resize
- Modern Mica backdrop with proper title bar integration

Fixes: Primary user interface for window resizing functionality
```

## Implementation Notes for Reviewers

This implementation creates a modern, floating context menu that follows Windows 11 Fluent Design guidelines. The UI is responsive and adapts based on the number of available windows. The WindowPositionHelper ensures the menu appears near the cursor while respecting screen boundaries. The auto-hide behavior provides a natural user experience similar to context menus in other applications. The preset button layout uses a 2x4 grid for common screen resolutions with clear visual hierarchy.

## What Comes Next

Once this PR is merged:
- PR 2.2 (Preset Size Buttons) can begin, which will expand the preset functionality
- The basic floating menu UI is now functional for testing and user feedback
- Consider future: May want to add animations, themes, and accessibility improvements