# PR 2.2: Preset Size Buttons

**Branch Name:** `2.2-preset-size-buttons`

**Description:** Implement predefined window resize preset buttons (1920×1080, 1366×768, 1280×720, 1024×768) with functional binding to resize logic and visual feedback for the active selection.

**Technology Stack:** .NET 8, WinUI 3 (Windows App SDK), C#, Win32 P/Invoke (SetWindowPos, ShowWindow)

**Dependencies:** Requires completion of PRs 1.1 (Global Hotkey), 1.2 (Window Enumeration), 1.3 (Window Resizing Logic), and 2.1 (Main Window Layout).

**Part of Phase:** Phase 2 – UI Layer (Enhances main floating menu with actionable preset buttons)

## Pre-Implementation Checklist

- [x] **Branch Creation:**
  ```bash
  cd x:/burkeholland/ResizeMe
  git checkout main
  git pull
  git checkout -b 2.2-preset-size-buttons
  ```

- [x] **Verify Project Setup:**
  ```bash
  dotnet build ResizeMe.sln
  ```
  Expected output: Build succeeds with zero errors; DLLs produced under `ResizeMe/bin/<arch>/Debug/net8.0-windows10.0.19041.0/`.

## Implementation Steps

### Step 1: Add Shared Styles For Preset Buttons

**Goal:** Introduce reusable styles + accent/highlight state for active preset buttons.

**File to Edit:** `ResizeMe/App.xaml`

**Checklist:**
- [x] Open `ResizeMe/App.xaml`.
- [x] Insert styles inside `<Application.Resources>` (do not remove existing resources).
- [x] Copy and paste the entire content below, replacing the file content (merges new resources with existing typical WinUI structure).

```xml
<?xml version="1.0" encoding="utf-8"?>
<Application
    x:Class="ResizeMe.App"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:ResizeMe">

    <Application.Resources>
        <!-- Existing theme resources remain available via ThemeResource lookup -->

        <!-- Base style for preset buttons -->
        <Style x:Key="PresetButtonBaseStyle" TargetType="Button" BasedOn="{StaticResource DefaultButtonStyle}">
            <Setter Property="Height" Value="48"/>
            <Setter Property="Margin" Value="0,4,4,4"/>
            <Setter Property="HorizontalAlignment" Value="Stretch"/>
            <Setter Property="Padding" Value="8"/>
            <Setter Property="CornerRadius" Value="6"/>
            <Setter Property="Background" Value="{ThemeResource ControlFillColorDefaultBrush}"/>
            <Setter Property="BorderBrush" Value="{ThemeResource ControlStrokeColorDefaultBrush}"/>
            <Setter Property="BorderThickness" Value="1"/>
            <Setter Property="ToolTipService.ToolTip" Value="Resize to preset dimensions"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Button">
                        <Grid x:Name="RootGrid" Background="{TemplateBinding Background}" CornerRadius="{TemplateBinding CornerRadius}">
                            <Border CornerRadius="{TemplateBinding CornerRadius}" BorderBrush="{TemplateBinding BorderBrush}" BorderThickness="{TemplateBinding BorderThickness}"/>
                            <ContentPresenter x:Name="ContentPresenter" HorizontalAlignment="Center" VerticalAlignment="Center"/>
                        </Grid>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsPointerOver" Value="True">
                                <Setter Target="RootGrid.Background" Property="Panel.Background" Value="{ThemeResource ControlFillColorSecondaryBrush}"/>
                            </Trigger>
                            <Trigger Property="IsPressed" Value="True">
                                <Setter Target="RootGrid.Background" Property="Panel.Background" Value="{ThemeResource AccentFillColorDefaultBrush}"/>
                                <Setter Property="Foreground" Value="{ThemeResource TextOnAccentFillColorPrimaryBrush}"/>
                            </Trigger>
                            <Trigger Property="IsEnabled" Value="False">
                                <Setter Target="RootGrid.Background" Property="Panel.Background" Value="{ThemeResource ControlFillColorDisabledBrush}"/>
                                <Setter Property="Foreground" Value="{ThemeResource TextFillColorDisabledBrush}"/>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>

        <!-- Active (selected) preset style -->
        <Style x:Key="ActivePresetButtonStyle" TargetType="Button" BasedOn="{StaticResource PresetButtonBaseStyle}">
            <Setter Property="Background" Value="{ThemeResource AccentFillColorDefaultBrush}"/>
            <Setter Property="Foreground" Value="{ThemeResource TextOnAccentFillColorPrimaryBrush}"/>
            <Setter Property="BorderBrush" Value="{ThemeResource AccentStrokeColorDefaultBrush}"/>
        </Style>

        <!-- Header text style for preset labels -->
        <Style x:Key="PresetHeaderTextStyle" TargetType="TextBlock" BasedOn="{StaticResource BodyStrongTextBlockStyle}">
            <Setter Property="FontSize" Value="14"/>
            <Setter Property="TextWrapping" Value="Wrap"/>
        </Style>

        <!-- Sub text style -->
        <Style x:Key="PresetSubTextStyle" TargetType="TextBlock" BasedOn="{StaticResource CaptionTextBlockStyle}">
            <Setter Property="Opacity" Value="0.8"/>
        </Style>
    </Application.Resources>
</Application>
```

**Verification:**
- [x] Build solution: no XAML parse errors.
- [x] Open `App.xaml` and confirm styles appear with syntax highlighting.
- [x] No duplicate resource key warnings in Output window when running.

---

### Step 2: Update MainWindow XAML With Standardized Preset Buttons

**Goal:** Ensure only required presets (1920×1080, 1366×768, 1280×720, 1024×768) are defined, using new styles, and tag metadata is consistent (`WIDTHxHEIGHT`).

**File to Edit:** `ResizeMe/MainWindow.xaml`

**Checklist:**
- [x] Replace preset button block with provided version.
- [x] Preserve all unrelated existing UI sections (title bar, window selection, footer).
- [x] Copy entire file content below and overwrite existing file.

```xml
<?xml version="1.0" encoding="utf-8"?>
<Window
    x:Class="ResizeMe.MainWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:ResizeMe">

    <Window.SystemBackdrop>
        <MicaBackdrop Kind="BaseAlt"/>
    </Window.SystemBackdrop>

    <Border Background="{ThemeResource CardBackgroundFillColorDefaultBrush}"
            CornerRadius="8"
            BorderThickness="1"
            BorderBrush="{ThemeResource CardStrokeColorDefaultBrush}">
        <Grid x:Name="RootGrid">
            <Grid.RowDefinitions>
                <RowDefinition Height="48"/>
                <RowDefinition Height="*"/>
                <RowDefinition Height="Auto"/>
            </Grid.RowDefinitions>

            <!-- Title Bar -->
            <Grid x:Name="TitleBar" Grid.Row="0" Background="Transparent" Margin="16,8,16,8">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>
                <StackPanel Grid.Column="0" Orientation="Horizontal" VerticalAlignment="Center">
                    <FontIcon FontFamily="Segoe Fluent Icons" Glyph="&#xE8B9;" FontSize="16" Foreground="{ThemeResource AccentAAFillColorDefaultBrush}" Margin="0,0,8,0"/>
                    <TextBlock Text="ResizeMe" FontWeight="SemiBold" FontSize="14" VerticalAlignment="Center" Foreground="{ThemeResource TextFillColorPrimaryBrush}"/>
                </StackPanel>
                <TextBlock x:Name="StatusText" Grid.Column="1" Text="Ready" FontSize="12" VerticalAlignment="Center" HorizontalAlignment="Center" Foreground="{ThemeResource TextFillColorSecondaryBrush}" Margin="8,0"/>
                <Button x:Name="SettingsButton" Grid.Column="2" Style="{ThemeResource SubtleButtonStyle}" Width="32" Height="32" Padding="4" ToolTipService.ToolTip="Settings" Click="SettingsButton_Click">
                    <FontIcon FontFamily="Segoe Fluent Icons" Glyph="&#xE713;" FontSize="14"/>
                </Button>
            </Grid>

            <!-- Content -->
            <ScrollViewer Grid.Row="1" Margin="16,8,16,16" VerticalScrollBarVisibility="Auto" HorizontalScrollBarVisibility="Disabled">
                <StackPanel Spacing="16">
                    <!-- Presets Section -->
                    <StackPanel x:Name="PresetsSection" Spacing="12">
                        <TextBlock Text="Quick Resize" FontWeight="SemiBold" FontSize="16" Foreground="{ThemeResource TextFillColorPrimaryBrush}"/>
                        <Grid x:Name="PresetsGrid">
                            <Grid.RowDefinitions>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                            </Grid.RowDefinitions>
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="*"/>
                                <ColumnDefinition Width="*"/>
                            </Grid.ColumnDefinitions>

                            <!-- 1280x720 -->
                            <Button x:Name="Preset1280x720" Grid.Row="0" Grid.Column="0" Style="{StaticResource PresetButtonBaseStyle}" Tag="1280x720" Click="PresetButton_Click" Margin="0,0,4,4">
                                <StackPanel Orientation="Vertical" Spacing="2">
                                    <TextBlock Text="HD" Style="{StaticResource PresetHeaderTextStyle}"/>
                                    <TextBlock Text="1280×720" Style="{StaticResource PresetSubTextStyle}"/>
                                </StackPanel>
                            </Button>

                            <!-- 1920x1080 -->
                            <Button x:Name="Preset1920x1080" Grid.Row="0" Grid.Column="1" Style="{StaticResource PresetButtonBaseStyle}" Tag="1920x1080" Click="PresetButton_Click" Margin="4,0,0,4">
                                <StackPanel Orientation="Vertical" Spacing="2">
                                    <TextBlock Text="Full HD" Style="{StaticResource PresetHeaderTextStyle}"/>
                                    <TextBlock Text="1920×1080" Style="{StaticResource PresetSubTextStyle}"/>
                                </StackPanel>
                            </Button>

                            <!-- 1366x768 -->
                            <Button x:Name="Preset1366x768" Grid.Row="1" Grid.Column="0" Style="{StaticResource PresetButtonBaseStyle}" Tag="1366x768" Click="PresetButton_Click" Margin="0,4,4,0">
                                <StackPanel Orientation="Vertical" Spacing="2">
                                    <TextBlock Text="Laptop" Style="{StaticResource PresetHeaderTextStyle}"/>
                                    <TextBlock Text="1366×768" Style="{StaticResource PresetSubTextStyle}"/>
                                </StackPanel>
                            </Button>

                            <!-- 1024x768 -->
                            <Button x:Name="Preset1024x768" Grid.Row="1" Grid.Column="1" Style="{StaticResource PresetButtonBaseStyle}" Tag="1024x768" Click="PresetButton_Click" Margin="4,4,0,0">
                                <StackPanel Orientation="Vertical" Spacing="2">
                                    <TextBlock Text="Classic" Style="{StaticResource PresetHeaderTextStyle}"/>
                                    <TextBlock Text="1024×768" Style="{StaticResource PresetSubTextStyle}"/>
                                </StackPanel>
                            </Button>
                        </Grid>
                    </StackPanel>

                    <!-- Placeholder for future sections (kept minimal for PR scope) -->
                </StackPanel>
            </ScrollViewer>

            <!-- Footer -->
            <Border Grid.Row="2" Background="{ThemeResource ControlFillColorDefaultBrush}" CornerRadius="0,0,8,8" Padding="16,8">
                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="*"/>
                        <ColumnDefinition Width="Auto"/>
                    </Grid.ColumnDefinitions>
                    <TextBlock Text="Press Win+Shift+F12 to show" FontSize="11" VerticalAlignment="Center" Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
                </Grid>
            </Border>
        </Grid>
    </Border>
</Window>
```

**Verification:**
- [x] Build succeeds; no invalid XAML warnings.
- [x] Four preset buttons appear with labels.
- [x] Button hover/press states visually respond.

---

### Step 3: Implement Active Preset Highlight & Binding Logic

**Goal:** Bind button clicks to window resizing logic using existing `WindowResizer`; highlight the active preset after success.

**File to Edit:** `ResizeMe/MainWindow.xaml.cs`

**Checklist:**
- [x] Add private field tracking active preset.
- [x] Add method `SetActivePreset(string sizeTag)` to apply `ActivePresetButtonStyle`.
- [x] Update `PresetButton_Click` to call resize and style update.
- [x] Maintain existing hotkey and window management behavior.
- [x] Copy and paste complete updated file content below.

```csharp
using Microsoft.UI;
using Microsoft.UI.Windowing;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using ResizeMe.Native;
using ResizeMe.Services;
using ResizeMe.Models;
using ResizeMe.Helpers;
using WinRT.Interop;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using Windows.Graphics;

namespace ResizeMe
{
    /// <summary>
    /// Floating context menu window providing preset resize buttons.
    /// </summary>
    public sealed partial class MainWindow : Window
    {
        private HotKeyManager? _hotKeyManager;
        private WindowManager? _windowManager;
        private WindowResizer? _windowResizer;
        private IntPtr _windowHandle = IntPtr.Zero;
        private AppWindow? _appWindow;
        private bool _isSubclassRegistered;
        private bool _isVisible;
        private bool _isAlwaysOnTop = false;
        private WindowInfo? _selectedWindow;
        private List<WindowInfo> _availableWindows = new();
        private string? _activePresetTag; // Tracks current active preset (e.g., "1280x720")

        private WinApiSubClass.SubClassProc? _subclassProc; // Keep delegate alive
        private IntPtr _subClassId = new IntPtr(1001);

        public MainWindow()
        {
            InitializeComponent();
            _windowManager = new WindowManager();
            _windowResizer = new WindowResizer();
            SetupWindowAppearance();
            Activated += OnWindowActivated;
            Closed += Window_Closed;
            Debug.WriteLine("MainWindow: Initialized");
        }

        /// <summary>
        /// Configures window appearance (size, hidden by default).
        /// </summary>
        private void SetupWindowAppearance()
        {
            try
            {
                Title = "ResizeMe";
                ExtendsContentIntoTitleBar = true;
                SetTitleBar(TitleBar);
                EnsureWindowHandle();
                if (_windowHandle != IntPtr.Zero)
                {
                    var windowId = Win32Interop.GetWindowIdFromWindow(_windowHandle);
                    _appWindow = AppWindow.GetFromWindowId(windowId);
                    _appWindow?.Resize(new SizeInt32(280, 320));
                    WindowsApi.ShowWindow(_windowHandle, WindowsApi.SW_HIDE);
                }
                _isVisible = false;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"MainWindow: Appearance error: {ex.Message}");
            }
        }

        /// <summary>
        /// Ensures HWND retrieval.
        /// </summary>
        private void EnsureWindowHandle()
        {
            if (_windowHandle != IntPtr.Zero) return;
            _windowHandle = WindowNative.GetWindowHandle(this);
            if (_windowHandle != IntPtr.Zero && _appWindow == null)
            {
                var windowId = Win32Interop.GetWindowIdFromWindow(_windowHandle);
                _appWindow = AppWindow.GetFromWindowId(windowId);
            }
        }

        /// <summary>
        /// Registers hotkey & subclass for message processing.
        /// </summary>
        private void EnsureHotKeyRegistration()
        {
            EnsureWindowHandle();
            if (_windowHandle == IntPtr.Zero || _hotKeyManager != null) return;
            _hotKeyManager = new HotKeyManager(_windowHandle);
            _hotKeyManager.HotKeyPressed += OnHotKeyPressed;
            bool success = _hotKeyManager.RegisterHotKey();
            StatusText.Text = success ? "Ready" : "Hotkey failed";
            Debug.WriteLine(success ? "Hotkey registered" : "Hotkey registration failed");
            if (!_isSubclassRegistered)
            {
                _subclassProc = WndProcSubClass;
                if (WinApiSubClass.SetWindowSubclass(_windowHandle, _subclassProc, _subClassId, IntPtr.Zero))
                {
                    _isSubclassRegistered = true;
                }
            }
            HideWindow();
        }

        /// <summary>
        /// Hotkey event: toggle visibility.
        /// </summary>
        private void OnHotKeyPressed(object? sender, EventArgs e)
        {
            if (_isVisible) HideWindow(); else ShowWindow();
        }

        /// <summary>
        /// Shows the menu and centers it relative to active window or screen.
        /// </summary>
        private void ShowWindow()
        {
            try
            {
                EnsureWindowHandle();
                RefreshWindowList();
                WindowInfo? anchorWindow = _windowManager?.GetActiveResizableWindow();
                if (anchorWindow == null) anchorWindow = _availableWindows.FirstOrDefault();
                if (_windowHandle != IntPtr.Zero)
                {
                    WindowsApi.ShowWindow(_windowHandle, WindowsApi.SW_RESTORE);
                    WindowsApi.BringWindowToTop(_windowHandle);
                    WindowsApi.SetForegroundWindow(_windowHandle);
                    ApplyAlwaysOnTop();
                }
                Activate();
                if (anchorWindow != null) WindowPositionHelper.CenterOnWindow(this, anchorWindow); else WindowPositionHelper.CenterOnScreen(this);
                _isVisible = true;
                StatusText.Text = $"Presets ready";
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"MainWindow: Show error {ex.Message}");
                StatusText.Text = "Show error";
            }
        }

        /// <summary>
        /// Hides the floating window.
        /// </summary>
        private void HideWindow()
        {
            try
            {
                EnsureWindowHandle();
                if (_windowHandle != IntPtr.Zero) WindowsApi.ShowWindow(_windowHandle, WindowsApi.SW_HIDE);
                _isVisible = false;
                StatusText.Text = "Hidden";
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"MainWindow: Hide error {ex.Message}");
            }
        }

        /// <summary>
        /// Refresh available windows (simplified for this PR scope).
        /// </summary>
        private void RefreshWindowList()
        {
            try
            {
                if (_windowManager == null) return;
                _availableWindows = _windowManager.GetResizableWindows().ToList();
                _selectedWindow = _availableWindows.FirstOrDefault();
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"MainWindow: Refresh error {ex.Message}");
            }
        }

        /// <summary>
        /// Resize handler invoked by preset buttons.
        /// </summary>
        private async void PresetButton_Click(object sender, RoutedEventArgs e)
        {
            if (sender is not Button btn || btn.Tag is not string sizeTag) return;
            var parts = sizeTag.Split('x');
            if (parts.Length != 2 || !int.TryParse(parts[0], out int width) || !int.TryParse(parts[1], out int height))
            {
                StatusText.Text = "Invalid size";
                return;
            }
            await ResizeSelectedWindow(width, height, sizeTag);
        }

        /// <summary>
        /// Core resize operation and post-success UI update.
        /// </summary>
        private async Task ResizeSelectedWindow(int width, int height, string sizeTag)
        {
            try
            {
                var targetWindow = _selectedWindow ?? _availableWindows.FirstOrDefault();
                if (targetWindow == null)
                {
                    StatusText.Text = "No window";
                    return;
                }
                if (_windowResizer == null)
                {
                    StatusText.Text = "No resizer";
                    return;
                }
                StatusText.Text = $"Resizing {sizeTag}...";
                var result = _windowResizer.ResizeWindow(targetWindow, width, height);
                if (result.Success)
                {
                    StatusText.Text = $"✅ {sizeTag}";
                    _windowResizer.ActivateWindow(targetWindow);
                    SetActivePreset(sizeTag);
                    await Task.Delay(900);
                    HideWindow();
                }
                else
                {
                    StatusText.Text = $"❌ {result.ErrorMessage}";
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"MainWindow: Resize error {ex.Message}");
                StatusText.Text = "Resize failed";
            }
        }

        /// <summary>
        /// Highlights the active preset button using style swap.
        /// </summary>
        private void SetActivePreset(string sizeTag)
        {
            _activePresetTag = sizeTag;
            var activeStyle = (Style?)App.Current.Resources["ActivePresetButtonStyle"];
            var baseStyle = (Style?)App.Current.Resources["PresetButtonBaseStyle"];
            if (PresetsGrid == null || activeStyle == null || baseStyle == null) return;
            foreach (var child in PresetsGrid.Children.OfType<Button>())
            {
                if (child.Tag is string tag && tag == sizeTag)
                {
                    child.Style = activeStyle;
                }
                else
                {
                    child.Style = baseStyle;
                }
            }
        }

        private void Window_Closed(object sender, WindowEventArgs e)
        {
            _hotKeyManager?.Dispose();
            if (_isSubclassRegistered && _windowHandle != IntPtr.Zero && _subclassProc != null)
            {
                WinApiSubClass.RemoveWindowSubclass(_windowHandle, _subclassProc, _subClassId);
                _isSubclassRegistered = false;
            }
        }

        private void OnWindowActivated(object sender, WindowActivatedEventArgs args)
        {
            if (args.WindowActivationState == WindowActivationState.Deactivated)
            {
                if (_isVisible && !_isAlwaysOnTop) HideWindow();
                return;
            }
            EnsureHotKeyRegistration();
        }

        private void ApplyAlwaysOnTop()
        {
            if (_windowHandle == IntPtr.Zero) return;
            var insertAfter = _isAlwaysOnTop ? WindowsApi.HWND_TOPMOST : WindowsApi.HWND_NOTOPMOST;
            WindowsApi.SetWindowPos(_windowHandle, insertAfter, 0, 0, 0, 0, WindowsApi.SWP_NOMOVE | WindowsApi.SWP_NOSIZE | WindowsApi.SWP_NOACTIVATE);
        }

        /// <summary>
        /// Subclass procedure to process messages (hotkey delegation).
        /// </summary>
        private IntPtr WndProcSubClass(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam, IntPtr uIdSubclass, IntPtr dwRefData)
        {
            if (_hotKeyManager?.ProcessMessage(uMsg, wParam, lParam) == true) return IntPtr.Zero;
            return WinApiSubClass.DefSubclassProc(hWnd, uMsg, wParam, lParam);
        }
    }

    /// <summary>
    /// Win32 subclass helper.
    /// </summary>
    internal static class WinApiSubClass
    {
        public delegate IntPtr SubClassProc(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam, IntPtr uIdSubclass, IntPtr dwRefData);
        [DllImport("comctl32.dll")] public static extern bool SetWindowSubclass(IntPtr hWnd, SubClassProc pfnSubclass, IntPtr uIdSubclass, IntPtr dwRefData);
        [DllImport("comctl32.dll")] public static extern IntPtr DefSubclassProc(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam);
        [DllImport("comctl32.dll")] public static extern bool RemoveWindowSubclass(IntPtr hWnd, SubClassProc pfnSubclass, IntPtr uIdSubclass);
    }
}
```

**Verification:**
- [x] Build solution: no compilation errors.
- [x] Launch app: hotkey shows window; click a preset resizes active window.
- [x] Active button changes to accent style; others revert.
- [x] Status text shows success (✅ tag) briefly before window hides.

---

### Step 4: Manual Functional Test

**Goal:** Validate end-to-end preset resize behavior and visual feedback.

**Checklist:**
- [ ] Start application (`dotnet run --project ResizeMe/ResizeMe.csproj`).
- [ ] Ensure a resizable window (e.g., Notepad) is open and focused.
- [ ] Press hotkey (Win+Shift+F12) – preset menu appears.
- [ ] Click each preset; target window resizes to specified dimensions (allow minor OS border variance).
- [ ] Active preset button style switches correctly per click.
- [ ] No crashes or unhandled exceptions in Debug Output.

**Verification:**
- [ ] Measured window width/height (use Win+Shift+Arrow or third-party tool) matches preset values ± window frame.

---

## Build and Final Verification

**Checklist:**
- [x] Build:
  ```bash
  dotnet build ResizeMe.sln
  ```
  Expected: `Build succeeded.` 0 errors, 0 warnings (warnings acceptable if unrelated to PR changes).
- [ ] Run & test presets as above.
- [ ] Confirm no XAML runtime binding failures in Output window.
- [ ] Confirm hotkey toggles menu reliably.

- [ ] Debugging Steps if Failure:
  - [ ] Check resource style keys exist (`PresetButtonBaseStyle`, `ActivePresetButtonStyle`).
  - [ ] Verify `Tag` formatting EXACTLY `WIDTHxHEIGHT` (no spaces).
  - [ ] Confirm `_windowResizer` is non-null (constructor executed).
  - [ ] Inspect `Marshal.GetLastWin32Error()` after hotkey registration failure.

## Expected Behavior After Completion

- [ ] Four preset buttons display with consistent styling.
- [ ] Clicking a preset resizes the currently active external window.
- [ ] Active preset visually highlighted until another preset chosen.
- [ ] Status text reports operation success or failure clearly.

## Troubleshooting

| Issue | Solution |
|-------|----------|
| Buttons show but no resize occurs | Ensure target window is a standard top-level window (not UWP) and focused before opening menu. Validate HWND in debugger. |
| Active preset style never applies | Ensure `App.xaml` styles loaded; confirm `Application.Resources` includes keys. Check `SetActivePreset` executing (add temporary Debug.WriteLine). |
| Hotkey does nothing | Conflict or registration failure (error 1409). Change modifiers or verify only one instance running. |
| Resize produces wrong dimensions | Window might be DPI-scaled or constrained. Test with non-maximized window; ensure not snapped. |
| Crash on click | Verify `Tag` value follows `widthxheight` pattern; guard added but malformed tags can still cause logic issues if manually edited. |
| Preset buttons missing | Confirm full overwrite of `MainWindow.xaml` and no merge conflicts. Clean/rebuild solution. |

## Files Created/Modified

- [ ] ✅ Modified: `ResizeMe/App.xaml`
- [ ] ✅ Modified: `ResizeMe/MainWindow.xaml`
- [ ] ✅ Modified: `ResizeMe/MainWindow.xaml.cs`
- [ ] ✅ No changes to: Other service/model files

## Commit Message Template

```
feat(ui): add functional preset size buttons with active highlight

Implements window resize presets (1920×1080, 1366×768, 1280×720, 1024×768) using existing WindowResizer service. Adds shared styles, active selection visual feedback, and integrates with global hotkey menu.

- Adds reusable preset button styles in App.xaml
- Updates MainWindow layout for standardized preset grid
- Implements active preset state logic and status feedback

Refs: Phase 2 PR 2.2
```

## Implementation Notes for Reviewers

- Style resources added to `App.xaml` to simplify future preset additions and avoid duplication. Active preset uses accent fill for immediate recognition.
- Logic confines changes to code-behind; service layer remains untouched to preserve SRP. Future enhancement could move preset management to a dedicated service.
- Visual feedback approach chosen over complex `VisualStateManager` usage for minimal overhead.

## What Comes Next

Once this PR is merged:
- PR 2.3 (Context Menu Toggle) can integrate visibility logic with existing preset highlight state.
- Enables dynamic loading of custom presets in Phase 3 by extending style + generation loop.
- Consider follow-up: Extract preset definitions to configuration/provider for user customization.
