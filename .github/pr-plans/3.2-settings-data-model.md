# PR 3.2: Settings Data Model

**Branch Name:** `3.2-settings-data-model`

**Description:** Implement persistent preset storage using JSON in LocalFolder and a `PresetManager` service.

**Technology Stack:** .NET 8, WinUI 3, System.Text.Json, Windows.Storage API

**Dependencies:** PR 3.1 (SettingsWindow UI). Requires existing services and models.

**Part of Phase:** Phase 3 – Persistence layer for presets.

## Pre-Implementation Checklist

- [x] Branch:
  ```bash
  cd x:/burkeholland/ResizeMe
  git checkout main
  git pull
  git checkout -b 3.2-settings-data-model
  ```
- [x] Build baseline:
  ```bash
  dotnet build ResizeMe.sln
  ```

## Implementation Steps

### Step 1: Create PresetSize Model

**Goal:** Define serializable preset data.

**File to Create:** `ResizeMe/Models/PresetSize.cs`

**Checklist:**
- [x] Add new model class with validation helpers.
- [x] Paste full content.

```csharp
using System.Text.Json.Serialization;

namespace ResizeMe.Models
{
    /// <summary>
    /// Represents a user-defined window size preset.
    /// </summary>
    public class PresetSize
    {
        /// <summary>Display name (e.g., "Full HD").</summary>
        public string Name { get; set; } = string.Empty;
        /// <summary>Width in pixels.</summary>
        public int Width { get; set; }
        /// <summary>Height in pixels.</summary>
        public int Height { get; set; }

        [JsonIgnore]
        public bool IsValid => Width > 0 && Height > 0 && !string.IsNullOrWhiteSpace(Name);

        public override string ToString() => $"{Name} ({Width}x{Height})";
    }
}
```

**Verification:**
- [x] Build succeeds (no warnings).

---

### Step 2: Create PresetManager Service

**Goal:** Manage CRUD + persistence for presets.

**File to Create:** `ResizeMe/Services/PresetManager.cs`

**Checklist:**
- [x] Implement load/save from JSON file `presets.json` in LocalFolder.
- [x] Provide thread-safe operations.
- [ ] Paste full content below.

```csharp
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;
using Windows.Storage;
using ResizeMe.Models;

namespace ResizeMe.Services
{
    /// <summary>
    /// Manages persistent preset sizes stored as JSON in LocalFolder.
    /// </summary>
    public class PresetManager
    {
        private const string FileName = "presets.json";
        private readonly object _syncRoot = new();
        private readonly JsonSerializerOptions _jsonOptions = new() { WriteIndented = true };
        private readonly List<PresetSize> _presets = new();
        private bool _loaded;

        /// <summary>Returns a snapshot of current presets.</summary>
        public IReadOnlyList<PresetSize> Presets
        {
            get { lock (_syncRoot) return _presets.ToList(); }
        }

        /// <summary>Loads presets from disk (idempotent).</summary>
        public async Task LoadAsync()
        {
            if (_loaded) return;
            try
            {
                var folder = ApplicationData.Current.LocalFolder;
                StorageFile? file = null;
                try { file = await folder.GetFileAsync(FileName); } catch { }
                if (file == null)
                {
                    SeedDefaults();
                    await SaveAsync();
                    _loaded = true;
                    return;
                }
                string json = await FileIO.ReadTextAsync(file);
                var data = JsonSerializer.Deserialize<List<PresetSize>>(json) ?? new List<PresetSize>();
                lock (_syncRoot)
                {
                    _presets.Clear();
                    _presets.AddRange(data.Where(p => p.IsValid));
                }
                if (!_presets.Any()) SeedDefaults();
                _loaded = true;
            }
            catch
            {
                lock (_syncRoot)
                {
                    _presets.Clear();
                    SeedDefaults();
                }
                _loaded = true;
            }
        }

        /// <summary>Persists presets to disk.</summary>
        public async Task SaveAsync()
        {
            List<PresetSize> snapshot;
            lock (_syncRoot) snapshot = _presets.ToList();
            var folder = ApplicationData.Current.LocalFolder;
            var file = await folder.CreateFileAsync(FileName, CreationCollisionOption.OpenIfExists);
            string json = JsonSerializer.Serialize(snapshot, _jsonOptions);
            await FileIO.WriteTextAsync(file, json);
        }

        /// <summary>Adds a preset if valid and unique.</summary>
        public async Task<bool> AddPresetAsync(PresetSize preset)
        {
            if (preset == null || !preset.IsValid) return false;
            lock (_syncRoot)
            {
                if (_presets.Any(p => p.Name.Equals(preset.Name, StringComparison.OrdinalIgnoreCase))) return false;
                _presets.Add(preset);
            }
            await SaveAsync();
            return true;
        }

        /// <summary>Removes a preset by name.</summary>
        public async Task<bool> RemovePresetAsync(string name)
        {
            if (string.IsNullOrWhiteSpace(name)) return false;
            bool removed = false;
            lock (_syncRoot)
            {
                var item = _presets.FirstOrDefault(p => p.Name.Equals(name, StringComparison.OrdinalIgnoreCase));
                if (item != null) removed = _presets.Remove(item);
            }
            if (removed) await SaveAsync();
            return removed;
        }

        /// <summary>Resets to default preset list.</summary>
        public async Task ResetToDefaultsAsync()
        {
            lock (_syncRoot)
            {
                _presets.Clear();
                SeedDefaults();
            }
            await SaveAsync();
        }

        private void SeedDefaults()
        {
            _presets.AddRange(new[]
            {
                new PresetSize { Name = "HD", Width = 1280, Height = 720 },
                new PresetSize { Name = "Full HD", Width = 1920, Height = 1080 },
                new PresetSize { Name = "Laptop", Width = 1366, Height = 768 },
                new PresetSize { Name = "Classic", Width = 1024, Height = 768 }
            });
        }
    }
}
```

**Verification:**
- [x] Build succeeds.
- [x] No warnings about nullable usage.

---

### Step 3: Replace Temporary Model Usage

**Goal:** Update `SettingsWindow` to use PresetManager instead of temporary list.

**File to Edit:** `ResizeMe/SettingsWindow.xaml.cs`

**Checklist:**
- [x] Replace entire file content with below implementation.

```csharp
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using ResizeMe.Models;
using ResizeMe.Services;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;
using System;

namespace ResizeMe
{
    /// <summary>
    /// Settings window with persistent preset management.
    /// </summary>
    public sealed partial class SettingsWindow : Window
    {
        private readonly PresetManager _manager = new();
        private readonly ObservableCollection<PresetSize> _viewPresets = new();

        public SettingsWindow()
        {
            InitializeComponent();
            Title = "ResizeMe Settings";
            PresetList.ItemsSource = _viewPresets;
            Loaded += SettingsWindow_Loaded;
        }

        private async void SettingsWindow_Loaded(object sender, RoutedEventArgs e)
        {
            await _manager.LoadAsync();
            RefreshView();
        }

        private void RefreshView()
        {
            _viewPresets.Clear();
            foreach (var p in _manager.Presets.OrderBy(p => p.Name)) _viewPresets.Add(p);
            StatusText.Text = $"Loaded {_viewPresets.Count} presets";
        }

        private async void AddButton_Click(object sender, RoutedEventArgs e)
        {
            string name = NameInput.Text.Trim();
            if (!int.TryParse(WidthInput.Text, out int width) || !int.TryParse(HeightInput.Text, out int height))
            {
                StatusText.Text = "Width/Height must be numbers"; return;
            }
            if (width <= 0 || height <= 0)
            {
                StatusText.Text = "Dimensions must be > 0"; return;
            }
            if (string.IsNullOrWhiteSpace(name)) name = $"{width}x{height}";
            var preset = new PresetSize { Name = name, Width = width, Height = height };
            bool added = await _manager.AddPresetAsync(preset);
            StatusText.Text = added ? $"Added {preset}" : "Duplicate name";
            if (added) RefreshView();
            NameInput.Text = WidthInput.Text = HeightInput.Text = string.Empty;
        }

        private async void RemoveButton_Click(object sender, RoutedEventArgs e)
        {
            if (PresetList.SelectedItem is PresetSize item)
            {
                bool removed = await _manager.RemovePresetAsync(item.Name);
                StatusText.Text = removed ? $"Removed {item.Name}" : "Remove failed";
                if (removed) RefreshView();
            }
            else StatusText.Text = "Nothing selected";
        }

        private async void RefreshButton_Click(object sender, RoutedEventArgs e)
        {
            await _manager.ResetToDefaultsAsync();
            RefreshView();
            StatusText.Text = "Defaults restored";
        }

        private void CloseButton_Click(object sender, RoutedEventArgs e) => Close();
    }
}
```

**Verification:**
- [x] Build succeeds.
- [ ] Run: add preset; close; reopen; preset persists.
- [ ] Reset restores defaults.

---

### Step 4: Wire MainWindow To Use Persistence (Optional preview)

**Goal:** Prepare for PR 3.4 by adding lazy load of PresetManager.

**File to Edit:** `ResizeMe/MainWindow.xaml.cs` (add field + load stub)

**Checklist:**
- [x] Insert field: `private readonly PresetManager _presetManager = new();`
- [x] Add async load in constructor after InitializeComponent: `Loaded += async (_, _) => await _presetManager.LoadAsync();`
- [ ] No dynamic UI yet (handled in PR 3.4).

```csharp
// Field near other private members
private readonly ResizeMe.Services.PresetManager _presetManager = new();

// In constructor after InitializeComponent();
Loaded += async (_, _) => await _presetManager.LoadAsync();
```

**Verification:**
- [ ] Build succeeds.
- [ ] No runtime exceptions on load.

---

## Build and Final Verification

- [x] Build:
  ```bash
  dotnet build ResizeMe.sln
  ```
- [ ] Run settings; add/remove; restart app and verify persistence.

## Expected Behavior After Completion

- [ ] Presets persist across sessions in `presets.json`.
- [ ] Duplicate names rejected.
- [ ] Defaults seeded when file missing/corrupt.

## Troubleshooting

| Issue | Solution |
|-------|----------|
| Presets not saving | Confirm LocalFolder access; ensure SaveAsync awaited. |
| Duplicate accepted | Check equality logic; name case-insensitive comparison. |
| File corruption | Delete `presets.json` manually; restart app (defaults re-seed). |
| Crash at load | Wrap LoadAsync call; ensure Windows.Storage API available (app identity required). |

## Files Created/Modified

- [ ] ✅ Created: `ResizeMe/Models/PresetSize.cs`
- [ ] ✅ Created: `ResizeMe/Services/PresetManager.cs`
- [ ] ✅ Modified: `ResizeMe/SettingsWindow.xaml.cs`
- [ ] ✅ Modified: `ResizeMe/MainWindow.xaml.cs` (preview field)

## Commit Message Template

```
feat(presets): add persistent PresetManager and PresetSize model

Introduces JSON-backed preset storage with CRUD and defaults seeding. Updates SettingsWindow to use persistence and primes MainWindow for dynamic integration.

- PresetSize model with validation
- PresetManager service (load/save/add/remove/reset)
- SettingsWindow persistence integration

Refs: Phase 3 PR 3.2
```

## Implementation Notes for Reviewers

- JSON chosen for simplicity; no external dependencies required.
- Thread safety ensured with lock around list operations.
- Future: consider migration to roaming settings (sync) or user profiles.

## What Comes Next

- PR 3.3 binds live updates & validation enhancements.
- PR 3.4 injects dynamic presets into main menu.
