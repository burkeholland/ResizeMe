# PR 1.1: Global Hotkey Registration

**Branch Name:** `feature/global-hotkey-registration`

**Description:** Implement system-wide hotkey listening (Ctrl+Alt+R) using Windows API with proper error handling and conflict resolution.

**Technology Stack:** WinUI 3, .NET 8.0, Windows API (P/Invoke), Windows App SDK 1.8

**Dependencies:** None - this is the foundational PR

**Part of Phase:** Phase 1: Core Infrastructure - establishes the foundation for triggering the app from anywhere in Windows

## Pre-Implementation Checklist

- [ ] **Branch Creation:** If not already on the main/default branch, run:
   ```powershell
   cd x:\burkeholland\ResizeMe
   git checkout main
   git pull
   git checkout -b feature/global-hotkey-registration
   ```

- [ ] **Verify Project Setup:** Ensure the project builds/runs successfully
   ```powershell
   dotnet build
   ```
   Expected output: Build succeeded with no errors or warnings

## Implementation Steps

### Step 1: Create Native Windows API Declarations

**Goal:** Create a dedicated class to handle P/Invoke declarations for hotkey registration APIs

**File to Create:** `ResizeMe/Native/WindowsApi.cs`

**Checklist:**
- [ ] Create folder called "Native" inside ResizeMe project folder
- [ ] Right-click Native folder → Add → Class
- [ ] Name the new class "WindowsApi.cs"
- [ ] Copy and paste the entire content below:

```csharp
using System;
using System.Runtime.InteropServices;

namespace ResizeMe.Native
{
    /// <summary>
    /// P/Invoke declarations for Windows API functions needed for global hotkey registration
    /// </summary>
    internal static class WindowsApi
    {
        // Constants for hotkey registration
        public const int WM_HOTKEY = 0x0312;
        public const int MOD_ALT = 0x0001;
        public const int MOD_CONTROL = 0x0002;
        public const int MOD_SHIFT = 0x0004;
        public const int MOD_WIN = 0x0008;

        // Virtual key codes
        public const int VK_R = 0x52;

        /// <summary>
        /// Registers a hotkey with the system
        /// </summary>
        /// <param name="hWnd">Handle to window that will receive WM_HOTKEY messages</param>
        /// <param name="id">Application-defined identifier for the hotkey</param>
        /// <param name="fsModifiers">Modifier keys (MOD_ALT, MOD_CONTROL, etc.)</param>
        /// <param name="vk">Virtual key code</param>
        /// <returns>True if successful, false if failed</returns>
        [DllImport("user32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool RegisterHotKey(IntPtr hWnd, int id, uint fsModifiers, uint vk);

        /// <summary>
        /// Unregisters a hotkey that was registered by RegisterHotKey
        /// </summary>
        /// <param name="hWnd">Handle to window that registered the hotkey</param>
        /// <param name="id">Application-defined identifier for the hotkey</param>
        /// <returns>True if successful, false if failed</returns>
        [DllImport("user32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool UnregisterHotKey(IntPtr hWnd, int id);
    }
}
```

**Verification:**
- [ ] File should have no build errors
- [ ] Syntax highlighting shows proper C# language recognition
- [ ] IntelliSense should work for the WindowsApi class

---

### Step 2: Create HotKey Manager Service

**Goal:** Create a service class that manages hotkey registration/unregistration with proper error handling

**File to Create:** `ResizeMe/Services/HotKeyManager.cs`

**Checklist:**
- [ ] Create folder called "Services" inside ResizeMe project folder
- [ ] Right-click Services folder → Add → Class
- [ ] Name the new class "HotKeyManager.cs"
- [ ] Copy and paste the entire content below:

```csharp
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using ResizeMe.Native;

namespace ResizeMe.Services
{
    /// <summary>
    /// Manages global hotkey registration and handles hotkey events
    /// </summary>
    public class HotKeyManager : IDisposable
    {
        private const int HOTKEY_ID = 9000; // Unique identifier for our hotkey
        private readonly IntPtr _windowHandle;
        private bool _isRegistered;
        private bool _disposed;

        /// <summary>
        /// Event fired when the registered hotkey is pressed
        /// </summary>
        public event EventHandler? HotKeyPressed;

        /// <summary>
        /// Gets whether the hotkey is currently registered
        /// </summary>
        public bool IsRegistered => _isRegistered;

        public HotKeyManager(IntPtr windowHandle)
        {
            _windowHandle = windowHandle;
        }

        /// <summary>
        /// Registers the global hotkey (Ctrl+Alt+R)
        /// </summary>
        public bool RegisterHotKey()
        {
            if (_isRegistered)
            {
                Debug.WriteLine("HotKeyManager: Hotkey is already registered");
                return true;
            }

            if (_windowHandle == IntPtr.Zero)
            {
                Debug.WriteLine("HotKeyManager: Invalid window handle");
                return false;
            }

            try
            {
                bool success = WindowsApi.RegisterHotKey(
                    _windowHandle,
                    HOTKEY_ID,
                    (uint)(WindowsApi.MOD_CONTROL | WindowsApi.MOD_ALT),
                    (uint)WindowsApi.VK_R);

                if (success)
                {
                    _isRegistered = true;
                    Debug.WriteLine("HotKeyManager: Successfully registered Ctrl+Alt+R hotkey");
                }
                else
                {
                    int errorCode = Marshal.GetLastWin32Error();
                    Debug.WriteLine($"HotKeyManager: Failed to register hotkey. Win32Error: {errorCode}");

                    // 1409 (ERROR_HOTKEY_ALREADY_REGISTERED) - hotkey already in use
                    if (errorCode == 1409)
                    {
                        Debug.WriteLine("HotKeyManager: Hotkey Ctrl+Alt+R is already registered by another application");
                    }
                }

                return success;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"HotKeyManager: Exception during hotkey registration: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// Unregisters the global hotkey
        /// </summary>
        public bool UnregisterHotKey()
        {
            if (!_isRegistered)
            {
                Debug.WriteLine("HotKeyManager: No hotkey to unregister");
                return true;
            }

            try
            {
                bool success = WindowsApi.UnregisterHotKey(_windowHandle, HOTKEY_ID);

                if (success)
                {
                    _isRegistered = false;
                    Debug.WriteLine("HotKeyManager: Successfully unregistered hotkey");
                }
                else
                {
                    int errorCode = Marshal.GetLastWin32Error();
                    Debug.WriteLine($"HotKeyManager: Failed to unregister hotkey. Win32Error: {errorCode}");
                }

                return success;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"HotKeyManager: Exception during hotkey unregistration: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// Processes Windows messages to detect hotkey presses
        /// </summary>
        public bool ProcessMessage(uint msg, IntPtr wParam, IntPtr lParam)
        {
            if (msg == WindowsApi.WM_HOTKEY && wParam.ToInt32() == HOTKEY_ID)
            {
                Debug.WriteLine("HotKeyManager: Hotkey pressed - firing event");
                OnHotKeyPressed();
                return true;
            }
            return false;
        }

        protected virtual void OnHotKeyPressed()
        {
            HotKeyPressed?.Invoke(this, EventArgs.Empty);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                if (_isRegistered)
                {
                    UnregisterHotKey();
                }
                _disposed = true;
            }
        }

        ~HotKeyManager()
        {
            Dispose(false);
        }
    }
}
```

**Verification:**
- [ ] File should have no build errors
- [ ] IntelliSense should show HotKeyManager class and its methods
- [ ] Debug namespace should resolve correctly

---

### Step 3: Integrate HotKey Manager with MainWindow

**Goal:** Connect the HotKeyManager to the main window and handle WM_HOTKEY messages

**File to Edit:** `ResizeMe/MainWindow.xaml.cs`

**Checklist:**
- [ ] Open MainWindow.xaml.cs file
- [ ] Add using statements at the top
- [ ] Add private field for HotKeyManager
- [ ] Initialize HotKeyManager in constructor
- [ ] Override WndProc to handle hotkey messages
- [ ] Copy and paste the entire content below:

```csharp
using Microsoft.UI.Xaml;
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using ResizeMe.Services;
using WinRT.Interop;

namespace ResizeMe
{
    public sealed partial class MainWindow : Window
    {
        private HotKeyManager? _hotKeyManager;
        private WinApiSubClass.SubClassProc? _subclassProc;
        private readonly IntPtr _subClassId = new IntPtr(1001);

        public MainWindow()
        {
            this.InitializeComponent();

            // Initialize hotkey manager after window is created
            this.Activated += MainWindow_Activated;
            this.Closed += MainWindow_Closed;

            Debug.WriteLine("MainWindow: Constructor completed");
        }

        private void MainWindow_Activated(object sender, WindowActivatedEventArgs args)
        {
            if (args.WindowActivationState != WindowActivationState.Deactivated && _hotKeyManager == null)
            {
                // Get the window handle (HWND) for this WinUI window
                IntPtr hwnd = WindowNative.GetWindowHandle(this);

                if (hwnd != IntPtr.Zero)
                {
                    _hotKeyManager = new HotKeyManager(hwnd);
                    _hotKeyManager.HotKeyPressed += HotKeyManager_HotKeyPressed;

                    bool success = _hotKeyManager.RegisterHotKey();
                    if (success)
                    {
                        Debug.WriteLine("MainWindow: Global hotkey Ctrl+Alt+R registered successfully");
                    }
                    else
                    {
                        Debug.WriteLine("MainWindow: Failed to register global hotkey");
                    }

                    // Hook into the window's message processing and keep delegate alive
                    _subclassProc = WndProcSubClass;
                    WinApiSubClass.SetWindowSubclass(hwnd, _subclassProc, _subClassId, IntPtr.Zero);
                }

                // Only need to do this once
                this.Activated -= MainWindow_Activated;
            }
        }

        private void HotKeyManager_HotKeyPressed(object? sender, EventArgs e)
        {
            Debug.WriteLine("MainWindow: Hotkey Ctrl+Alt+R was pressed!");
            this.Activate();
            this.Title = $"ResizeMe - Hotkey pressed at {DateTime.Now:HH:mm:ss}";
        }

        private IntPtr WndProcSubClass(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam, IntPtr uIdSubclass, IntPtr dwRefData)
        {
            if (_hotKeyManager?.ProcessMessage(uMsg, wParam, lParam) == true)
            {
                return IntPtr.Zero; // Message handled
            }

            return WinApiSubClass.DefSubclassProc(hWnd, uMsg, wParam, lParam);
        }

        private void MainWindow_Closed(object sender, WindowEventArgs args)
        {
            Debug.WriteLine("MainWindow: Closing - cleaning up hotkey registration");
            _hotKeyManager?.Dispose();

            // Remove subclass to be safe
            if (_subclassProc != null)
            {
                IntPtr hwnd = WindowNative.GetWindowHandle(this);
                if (hwnd != IntPtr.Zero)
                {
                    WinApiSubClass.RemoveWindowSubclass(hwnd, _subclassProc, _subClassId);
                }
            }
        }
    }

    internal static class WinApiSubClass
    {
        public delegate IntPtr SubClassProc(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam, IntPtr uIdSubclass, IntPtr dwRefData);

        [DllImport("comctl32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool SetWindowSubclass(IntPtr hWnd, SubClassProc pfnSubclass, IntPtr uIdSubclass, IntPtr dwRefData);

        [DllImport("comctl32.dll")]
        public static extern IntPtr DefSubclassProc(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam);

        [DllImport("comctl32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool RemoveWindowSubclass(IntPtr hWnd, SubClassProc pfnSubclass, IntPtr uIdSubclass);
    }
}
```

**Verification:**
- [ ] File should have no build errors
- [ ] Using statements should resolve correctly
- [ ] HotKeyManager class should be recognized by IntelliSense
- [ ] WindowNative.GetWindowHandle should resolve (this is part of WinUI)

---

### Step 4: Manifest Changes

No manifest changes are required for registering global hotkeys in a WinUI 3 desktop app. Keep your existing `Package.appxmanifest` as-is.

---

## Build and Final Verification

**Checklist:**
- [ ] **Build the project:**
   ```powershell
   dotnet build
   ```
   Expected: Build succeeded with 0 errors, 0 warnings

- [ ] **Check for errors:** There should be none. If you see errors:
   - [ ] Verify Native folder was created in the correct location (ResizeMe/Native/)
   - [ ] Check that all using statements are correct
   - [ ] Verify no typos in class names or method signatures
   - [ ] Ensure Package.appxmanifest has proper XML syntax

- [ ] **Manual Testing:**
    - [ ] Start the application with F5 in Visual Studio
   - [ ] Check Visual Studio Output window (Debug category)
   - [ ] Look for "Successfully registered Ctrl+Alt+R hotkey" message
   - [ ] Press Ctrl+Alt+R while app is running
   - [ ] Verify debug output shows "Hotkey Ctrl+Alt+R was pressed!"
   - [ ] Verify the window title updates with timestamp

## Expected Behavior After Completion

- [ ] Application builds and runs without errors
- [ ] Debug output shows successful hotkey registration on startup
- [ ] Pressing Ctrl+Alt+R triggers the hotkey event (visible in debug output)
- [ ] Window title changes to show timestamp when hotkey is pressed
- [ ] App activates/comes to front when hotkey is pressed
- [ ] Hotkey works even when app is not in focus
- [ ] App properly cleans up hotkey registration on exit

## Troubleshooting

| Issue | Solution |
|-------|----------|
| "Build error: Type or namespace 'Native' could not be found" | Verify the Native folder exists and WindowsApi.cs is in it. Check that the namespace is `ResizeMe.Native` |
| "Build error: Type or namespace 'Services' could not be found" | Verify the Services folder exists and HotKeyManager.cs is in it. Check that the namespace is `ResizeMe.Services` |
| "Hotkey registration fails with error 1409" | Another application is already using Ctrl+Alt+R. Try changing the key combination in WindowsApi.cs (e.g., VK_M for Ctrl+Alt+M) |
| "Debug output shows 'Invalid window handle'" | The window handle couldn't be obtained. Ensure you're calling the registration code after the window is fully activated |
| "DllImport errors for comctl32.dll" | Add `using System.Runtime.InteropServices;` at the top of MainWindow.xaml.cs |
| "No debug output visible" | In Visual Studio, go to View → Output, select "Debug" from the dropdown |

## Files Created/Modified

- [ ] ✅ Created: `ResizeMe/Native/WindowsApi.cs`
- [ ] ✅ Created: `ResizeMe/Services/HotKeyManager.cs`
- [ ] ✅ Modified: `ResizeMe/MainWindow.xaml.cs`
- [ ] ✅ No changes to: `ResizeMe/Package.appxmanifest`
- [ ] ✅ No changes to: `ResizeMe/App.xaml` or `ResizeMe/App.xaml.cs`

## Commit Message Template

```
feat(hotkey): implement global hotkey registration system

Adds system-wide Ctrl+Alt+R hotkey detection using Windows API P/Invoke.
Creates foundation for triggering resize menu from anywhere in Windows.

- Add WindowsApi class with RegisterHotKey/UnregisterHotKey P/Invoke
- Create HotKeyManager service with proper error handling and cleanup  
- Integrate hotkey processing with MainWindow message handling
- Add runFullTrust capability for system-level access

Fixes: Foundation for window resizing functionality
```

## Implementation Notes for Reviewers

This implementation uses the Windows API directly via P/Invoke rather than higher-level libraries to maintain lightweight dependencies and precise control. The HotKeyManager follows the dispose pattern to ensure proper cleanup of system resources. The window subclassing approach is necessary in WinUI to receive low-level Windows messages like WM_HOTKEY. Error handling includes specific logging for common failure scenarios like hotkey conflicts.

## What Comes Next

Once this PR is merged:
- PR 1.2 (Window Enumeration) can begin, which will discover open windows on the system
- This enables the core hotkey trigger mechanism that will eventually show the resize menu
- Consider future: May need to add configuration UI to let users change the hotkey combination