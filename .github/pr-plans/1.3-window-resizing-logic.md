# PR 1.3: Window Resizing Logic

**Branch Name:** `feature/window-resizing-logic`

**Description:** Implement core window resize functionality using SetWindowPos with proper handling of edge cases like minimized windows and modal dialogs.

**Technology Stack:** WinUI 3, .NET 8.0, Windows API (P/Invoke), Windows App SDK 1.8

**Dependencies:** 
- PR 1.1 (Global Hotkey Registration) - uses Windows API infrastructure
- PR 1.2 (Window Enumeration) - uses WindowInfo model and WindowManager service

**Part of Phase:** Phase 1: Core Infrastructure - provides the actual window manipulation capability

## Pre-Implementation Checklist

- [ ] **Branch Creation:** If not already on the main/default branch, run:
   ```powershell
   cd x:\burkeholland\ResizeMe
   git checkout main
   git pull
   git checkout -b feature/window-resizing-logic
   ```

- [ ] **Verify Project Setup:** Ensure the project builds/runs successfully
   ```powershell
   dotnet build
   ```
   Expected output: Build succeeded with no errors or warnings

## Implementation Steps

### Step 1: Extend Windows API for Window Positioning

**Goal:** Add P/Invoke declarations for window positioning and state manipulation APIs

**File to Edit:** `ResizeMe/Native/WindowsApi.cs`

**Checklist:**
- [ ] Open existing WindowsApi.cs file
- [ ] Add new constants for SetWindowPos flags
- [ ] Add API declarations for window manipulation
- [ ] Copy and paste the additional content below to the end of the class (before closing brace):

```csharp
        // Constants for SetWindowPos
        public const uint SWP_NOSIZE = 0x0001;
        public const uint SWP_NOMOVE = 0x0002;
        public const uint SWP_NOZORDER = 0x0004;
        public const uint SWP_NOREDRAW = 0x0008;
        public const uint SWP_NOACTIVATE = 0x0010;
        public const uint SWP_FRAMECHANGED = 0x0020;
        public const uint SWP_SHOWWINDOW = 0x0040;
        public const uint SWP_HIDEWINDOW = 0x0080;
        public const uint SWP_NOCOPYBITS = 0x0100;
        public const uint SWP_NOOWNERZORDER = 0x0200;
        public const uint SWP_NOSENDCHANGING = 0x0400;

        // Special HWND values for SetWindowPos
        public static readonly IntPtr HWND_TOP = new IntPtr(0);
        public static readonly IntPtr HWND_BOTTOM = new IntPtr(1);
        public static readonly IntPtr HWND_TOPMOST = new IntPtr(-1);
        public static readonly IntPtr HWND_NOTOPMOST = new IntPtr(-2);

        // ShowWindow constants
        public const int SW_HIDE = 0;
        public const int SW_SHOWNORMAL = 1;
        public const int SW_SHOWMINIMIZED = 2;
        public const int SW_SHOWMAXIMIZED = 3;
        public const int SW_SHOWNOACTIVATE = 4;
        public const int SW_SHOW = 5;
        public const int SW_MINIMIZE = 6;
        public const int SW_SHOWMINNOACTIVE = 7;
        public const int SW_SHOWNA = 8;
        public const int SW_RESTORE = 9;

        /// <summary>
        /// Changes the size, position, and Z order of a child, pop-up, or top-level window
        /// </summary>
        /// <param name="hWnd">Handle to the window</param>
        /// <param name="hWndInsertAfter">Handle to the window to precede this window in Z order</param>
        /// <param name="x">New position of the left side of the window</param>
        /// <param name="y">New position of the top of the window</param>
        /// <param name="cx">New width of the window</param>
        /// <param name="cy">New height of the window</param>
        /// <param name="flags">Window sizing and positioning flags</param>
        /// <returns>True if successful, false otherwise</returns>
        [DllImport("user32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int x, int y, int cx, int cy, uint flags);

        /// <summary>
        /// Sets the specified window's show state
        /// </summary>
        /// <param name="hWnd">Handle to the window</param>
        /// <param name="nCmdShow">Controls how the window is to be shown</param>
        /// <returns>True if the window was previously visible, false otherwise</returns>
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

        /// <summary>
        /// Brings the specified window to the top of the Z order
        /// </summary>
        /// <param name="hWnd">Handle to the window</param>
        /// <returns>True if successful, false otherwise</returns>
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool BringWindowToTop(IntPtr hWnd);

        /// <summary>
        /// Activates a window and displays it in its current size and position
        /// </summary>
        /// <param name="hWnd">Handle to the window</param>
        /// <returns>True if successful, false otherwise</returns>
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool SetForegroundWindow(IntPtr hWnd);

        /// <summary>
        /// Determines whether the specified window is maximized
        /// </summary>
        /// <param name="hWnd">Handle to the window</param>
        /// <returns>True if the window is maximized, false otherwise</returns>
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool IsZoomed(IntPtr hWnd);

        /// <summary>
        /// Retrieves information about the specified window's placement
        /// </summary>
        /// <param name="hWnd">Handle to the window</param>
        /// <param name="lpwndpl">Pointer to structure that receives placement information</param>
        /// <returns>True if successful, false otherwise</returns>
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool GetWindowPlacement(IntPtr hWnd, ref WINDOWPLACEMENT lpwndpl);

        /// <summary>
        /// Sets the show state and the restored, minimized, and maximized positions of the specified window
        /// </summary>
        /// <param name="hWnd">Handle to the window</param>
        /// <param name="lpwndpl">Pointer to structure that specifies the new position and show state</param>
        /// <returns>True if successful, false otherwise</returns>
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool SetWindowPlacement(IntPtr hWnd, ref WINDOWPLACEMENT lpwndpl);

        /// <summary>
        /// Structure containing information about the placement of a window on the screen
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct WINDOWPLACEMENT
        {
            public int length;
            public int flags;
            public int showCmd;
            public POINT ptMinPosition;
            public POINT ptMaxPosition;
            public RECT rcNormalPosition;

            public static WINDOWPLACEMENT Default
            {
                get
                {
                    var result = new WINDOWPLACEMENT();
                    result.length = Marshal.SizeOf(result);
                    return result;
                }
            }
        }

        /// <summary>
        /// Structure representing a point
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct POINT
        {
            public int X;
            public int Y;

            public POINT(int x, int y)
            {
                X = x;
                Y = y;
            }
        }
```

**Verification:**
- [ ] File should have no build errors
- [ ] All new constants should be properly defined
- [ ] SetWindowPos and related API methods should show up in IntelliSense
- [ ] WINDOWPLACEMENT and POINT structures should be properly defined

---

### Step 2: Create Resize Result Model

**Goal:** Create a model to represent the results of resize operations with detailed success/failure information

**File to Create:** `ResizeMe/Models/ResizeResult.cs`

**Checklist:**
- [ ] Right-click Models folder → Add → Class
- [ ] Name the new class "ResizeResult.cs"
- [ ] Copy and paste the entire content below:

```csharp
using System;

namespace ResizeMe.Models
{
    /// <summary>
    /// Represents the result of a window resize operation
    /// </summary>
    public class ResizeResult
    {
        /// <summary>
        /// Gets or sets whether the resize operation was successful
        /// </summary>
        public bool Success { get; set; }

        /// <summary>
        /// Gets or sets the error message if the operation failed
        /// </summary>
        public string? ErrorMessage { get; set; }

        /// <summary>
        /// Gets or sets the error code from the Windows API (if applicable)
        /// </summary>
        public uint? ErrorCode { get; set; }

        /// <summary>
        /// Gets or sets the window that was being resized
        /// </summary>
        public WindowInfo? TargetWindow { get; set; }

        /// <summary>
        /// Gets or sets the requested size
        /// </summary>
        public WindowSize? RequestedSize { get; set; }

        /// <summary>
        /// Gets or sets the actual size after the operation
        /// </summary>
        public WindowSize? ActualSize { get; set; }

        /// <summary>
        /// Gets or sets whether the window was restored from a minimized/maximized state
        /// </summary>
        public bool WindowStateChanged { get; set; }

        /// <summary>
        /// Gets a display-friendly message about the resize operation
        /// </summary>
        public string DisplayMessage
        {
            get
            {
                if (Success)
                {
                    var target = TargetWindow?.DisplayText ?? "Window";
                    var size = RequestedSize?.ToString() ?? "unknown size";
                    return $"Successfully resized {target} to {size}";
                }
                else
                {
                    return ErrorMessage ?? "Resize operation failed";
                }
            }
        }

        /// <summary>
        /// Creates a successful resize result
        /// </summary>
        /// <param name="targetWindow">The window that was resized</param>
        /// <param name="requestedSize">The requested size</param>
        /// <param name="actualSize">The actual resulting size</param>
        /// <param name="windowStateChanged">Whether window state was changed</param>
        /// <returns>ResizeResult indicating success</returns>
        public static ResizeResult Success(WindowInfo targetWindow, WindowSize requestedSize, WindowSize actualSize, bool windowStateChanged = false)
        {
            return new ResizeResult
            {
                Success = true,
                TargetWindow = targetWindow,
                RequestedSize = requestedSize,
                ActualSize = actualSize,
                WindowStateChanged = windowStateChanged
            };
        }

        /// <summary>
        /// Creates a failed resize result
        /// </summary>
        /// <param name="targetWindow">The window that failed to resize</param>
        /// <param name="requestedSize">The requested size</param>
        /// <param name="errorMessage">Description of the error</param>
        /// <param name="errorCode">Windows API error code if applicable</param>
        /// <returns>ResizeResult indicating failure</returns>
        public static ResizeResult Failure(WindowInfo targetWindow, WindowSize requestedSize, string errorMessage, uint? errorCode = null)
        {
            return new ResizeResult
            {
                Success = false,
                TargetWindow = targetWindow,
                RequestedSize = requestedSize,
                ErrorMessage = errorMessage,
                ErrorCode = errorCode
            };
        }

        /// <summary>
        /// Returns a string representation of the resize result
        /// </summary>
        public override string ToString()
        {
            return DisplayMessage;
        }
    }

    /// <summary>
    /// Represents a window size with width and height
    /// </summary>
    public class WindowSize
    {
        /// <summary>
        /// Gets or sets the width of the window
        /// </summary>
        public int Width { get; set; }

        /// <summary>
        /// Gets or sets the height of the window
        /// </summary>
        public int Height { get; set; }

        /// <summary>
        /// Initializes a new instance of WindowSize
        /// </summary>
        /// <param name="width">Width of the window</param>
        /// <param name="height">Height of the window</param>
        public WindowSize(int width, int height)
        {
            Width = width;
            Height = height;
        }

        /// <summary>
        /// Gets whether this is a valid window size
        /// </summary>
        public bool IsValid => Width > 0 && Height > 0;

        /// <summary>
        /// Returns a string representation of the window size
        /// </summary>
        public override string ToString()
        {
            return $"{Width}x{Height}";
        }

        /// <summary>
        /// Determines whether the specified object is equal to this window size
        /// </summary>
        /// <param name="obj">Object to compare</param>
        /// <returns>True if objects are equal</returns>
        public override bool Equals(object? obj)
        {
            return obj is WindowSize other && Width == other.Width && Height == other.Height;
        }

        /// <summary>
        /// Returns the hash code for this window size
        /// </summary>
        /// <returns>Hash code based on width and height</returns>
        public override int GetHashCode()
        {
            return HashCode.Combine(Width, Height);
        }
    }
}
```

**Verification:**
- [ ] File should have no build errors
- [ ] ResizeResult and WindowSize classes should be recognized
- [ ] Static factory methods should work correctly
- [ ] All properties and methods should appear in IntelliSense

---

### Step 3: Create Window Resizer Service

**Goal:** Create a service that handles the actual window resize operations with comprehensive error handling

**File to Create:** `ResizeMe/Services/WindowResizer.cs`

**Checklist:**
- [ ] Right-click Services folder → Add → Class
- [ ] Name the new class "WindowResizer.cs"
- [ ] Copy and paste the entire content below:

```csharp
using System;
using System.Diagnostics;
using ResizeMe.Models;
using ResizeMe.Native;

namespace ResizeMe.Services
{
    /// <summary>
    /// Service for resizing windows using Windows API
    /// </summary>
    public class WindowResizer
    {
        /// <summary>
        /// Resizes the specified window to the given dimensions
        /// </summary>
        /// <param name="windowInfo">Information about the window to resize</param>
        /// <param name="width">Target width</param>
        /// <param name="height">Target height</param>
        /// <returns>Result of the resize operation</returns>
        public ResizeResult ResizeWindow(WindowInfo windowInfo, int width, int height)
        {
            var requestedSize = new WindowSize(width, height);
            
            if (windowInfo?.Handle == null || windowInfo.Handle == IntPtr.Zero)
            {
                return ResizeResult.Failure(windowInfo!, requestedSize, "Invalid window handle");
            }

            if (!requestedSize.IsValid)
            {
                return ResizeResult.Failure(windowInfo, requestedSize, "Invalid target size (width and height must be greater than 0)");
            }

            try
            {
                Debug.WriteLine($"WindowResizer: Attempting to resize {windowInfo} to {requestedSize}");

                // Check if window still exists and is valid
                if (!IsWindowValid(windowInfo.Handle))
                {
                    return ResizeResult.Failure(windowInfo, requestedSize, "Window no longer exists or is not accessible");
                }

                // Handle minimized/maximized windows
                bool windowStateChanged = false;
                var currentState = GetWindowState(windowInfo.Handle);
                
                if (currentState != WindowState.Normal)
                {
                    Debug.WriteLine($"WindowResizer: Window is {currentState}, restoring to normal state");
                    if (!RestoreWindow(windowInfo.Handle))
                    {
                        return ResizeResult.Failure(windowInfo, requestedSize, 
                            $"Failed to restore window from {currentState} state", WindowsApi.GetLastError());
                    }
                    windowStateChanged = true;
                }

                // Get current window position to preserve it
                if (!WindowsApi.GetWindowRect(windowInfo.Handle, out var currentRect))
                {
                    return ResizeResult.Failure(windowInfo, requestedSize, 
                        "Failed to get current window position", WindowsApi.GetLastError());
                }

                // Perform the resize operation
                bool success = WindowsApi.SetWindowPos(
                    windowInfo.Handle,
                    WindowsApi.HWND_TOP,
                    currentRect.Left,  // Keep current X position
                    currentRect.Top,   // Keep current Y position
                    width,             // New width
                    height,            // New height
                    WindowsApi.SWP_NOZORDER | WindowsApi.SWP_NOACTIVATE | WindowsApi.SWP_SHOWWINDOW
                );

                if (!success)
                {
                    uint errorCode = WindowsApi.GetLastError();
                    string errorMessage = GetErrorMessage(errorCode);
                    return ResizeResult.Failure(windowInfo, requestedSize, errorMessage, errorCode);
                }

                // Verify the resize was successful by checking new dimensions
                if (!WindowsApi.GetWindowRect(windowInfo.Handle, out var newRect))
                {
                    Debug.WriteLine("WindowResizer: Warning - Could not verify new window size");
                }

                var actualSize = new WindowSize(newRect.Width, newRect.Height);
                Debug.WriteLine($"WindowResizer: Successfully resized to {actualSize}");

                return ResizeResult.Success(windowInfo, requestedSize, actualSize, windowStateChanged);
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"WindowResizer: Exception during resize: {ex.Message}");
                return ResizeResult.Failure(windowInfo, requestedSize, $"Unexpected error: {ex.Message}");
            }
        }

        /// <summary>
        /// Resizes a window using a WindowSize object
        /// </summary>
        /// <param name="windowInfo">Information about the window to resize</param>
        /// <param name="targetSize">Target size for the window</param>
        /// <returns>Result of the resize operation</returns>
        public ResizeResult ResizeWindow(WindowInfo windowInfo, WindowSize targetSize)
        {
            return ResizeWindow(windowInfo, targetSize.Width, targetSize.Height);
        }

        /// <summary>
        /// Gets the current state of a window
        /// </summary>
        /// <param name="hWnd">Handle to the window</param>
        /// <returns>Current window state</returns>
        private WindowState GetWindowState(IntPtr hWnd)
        {
            try
            {
                if (WindowsApi.IsIconic(hWnd))
                {
                    return WindowState.Minimized;
                }

                if (WindowsApi.IsZoomed(hWnd))
                {
                    return WindowState.Maximized;
                }

                return WindowState.Normal;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"WindowResizer: Error getting window state: {ex.Message}");
                return WindowState.Normal;
            }
        }

        /// <summary>
        /// Restores a window from minimized or maximized state
        /// </summary>
        /// <param name="hWnd">Handle to the window</param>
        /// <returns>True if successful, false otherwise</returns>
        private bool RestoreWindow(IntPtr hWnd)
        {
            try
            {
                // First try ShowWindow with SW_RESTORE
                bool success = WindowsApi.ShowWindow(hWnd, WindowsApi.SW_RESTORE);
                
                if (success)
                {
                    // Give the window time to restore
                    System.Threading.Thread.Sleep(100);
                    
                    // Verify it's actually restored
                    if (!WindowsApi.IsIconic(hWnd) && !WindowsApi.IsZoomed(hWnd))
                    {
                        return true;
                    }
                }

                // Fallback: Try using SetWindowPlacement
                var placement = WindowsApi.WINDOWPLACEMENT.Default;
                if (WindowsApi.GetWindowPlacement(hWnd, ref placement))
                {
                    placement.showCmd = WindowsApi.SW_SHOWNORMAL;
                    return WindowsApi.SetWindowPlacement(hWnd, ref placement);
                }

                return false;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"WindowResizer: Error restoring window: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// Checks if a window handle is still valid and accessible
        /// </summary>
        /// <param name="hWnd">Handle to check</param>
        /// <returns>True if valid, false otherwise</returns>
        private bool IsWindowValid(IntPtr hWnd)
        {
            try
            {
                // Try to get window rect - this will fail if window doesn't exist
                return WindowsApi.GetWindowRect(hWnd, out var _);
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Gets a user-friendly error message for common Windows API error codes
        /// </summary>
        /// <param name="errorCode">Windows API error code</param>
        /// <returns>Human-readable error message</returns>
        private string GetErrorMessage(uint errorCode)
        {
            return errorCode switch
            {
                0 => "Operation completed successfully",
                5 => "Access denied - the window may be owned by a privileged process",
                6 => "Invalid handle - the window may have been closed",
                87 => "Invalid parameter - the specified coordinates may be out of range",
                1400 => "Invalid window handle - the window no longer exists",
                1401 => "Invalid menu handle",
                1402 => "Invalid cursor handle",
                1403 => "Invalid accelerator table handle",
                1404 => "Invalid hook handle",
                1405 => "Invalid DWP (Deferred Window Position) handle",
                1406 => "Cannot create top-level child window",
                1407 => "Cannot find window class",
                1408 => "Invalid window - cannot find window",
                1409 => "Invalid index",
                _ => $"Windows API error {errorCode}"
            };
        }

        /// <summary>
        /// Activates a window and brings it to the foreground
        /// </summary>
        /// <param name="windowInfo">Information about the window to activate</param>
        /// <returns>True if successful, false otherwise</returns>
        public bool ActivateWindow(WindowInfo windowInfo)
        {
            if (windowInfo?.Handle == null || windowInfo.Handle == IntPtr.Zero)
            {
                return false;
            }

            try
            {
                // Restore if minimized
                if (WindowsApi.IsIconic(windowInfo.Handle))
                {
                    WindowsApi.ShowWindow(windowInfo.Handle, WindowsApi.SW_RESTORE);
                }

                // Bring to front and activate
                bool success = WindowsApi.SetForegroundWindow(windowInfo.Handle);
                if (!success)
                {
                    // Fallback: Try BringWindowToTop
                    success = WindowsApi.BringWindowToTop(windowInfo.Handle);
                }

                return success;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"WindowResizer: Error activating window: {ex.Message}");
                return false;
            }
        }
    }

    /// <summary>
    /// Enumeration of possible window states
    /// </summary>
    internal enum WindowState
    {
        Normal,
        Minimized,
        Maximized
    }
}
```

**Verification:**
- [ ] File should have no build errors
- [ ] WindowResizer class and its methods should appear in IntelliSense
- [ ] All using statements should resolve correctly
- [ ] WindowState enum should be properly defined

---

### Step 4: Add Resize Testing to MainWindow

**Goal:** Integrate WindowResizer into MainWindow to test resizing functionality when hotkey is pressed

**File to Edit:** `ResizeMe/MainWindow.xaml.cs`

**Checklist:**
- [ ] Open MainWindow.xaml.cs file
- [ ] Add private field for WindowResizer
- [ ] Initialize WindowResizer in constructor
- [ ] Update hotkey handler to test window resizing
- [ ] Find the existing hotkey handler method and replace it with enhanced testing logic:

```csharp
        private WindowResizer? _windowResizer;

        public MainWindow()
        {
            this.InitializeComponent();
            
            // Initialize services
            _windowManager = new WindowManager();
            _windowResizer = new WindowResizer();
            
            // Initialize hotkey manager after window is created
            this.Activated += MainWindow_Activated;
            this.Closed += MainWindow_Closed;
            
            Debug.WriteLine("MainWindow: Constructor completed");
        }

        /// <summary>
        /// Handles the hotkey press event
        /// </summary>
        private void HotKeyManager_HotKeyPressed(object? sender, EventArgs e)
        {
            Debug.WriteLine("MainWindow: Hotkey Ctrl+Alt+R was pressed!");
            
            try
            {
                // Get list of resizable windows
                var windows = _windowManager?.GetResizableWindows();
                if (windows != null && windows.Any())
                {
                    Debug.WriteLine($"MainWindow: Found {windows.Count()} resizable windows");
                    
                    // For testing, resize the first window to 800x600
                    var firstWindow = windows.First();
                    Debug.WriteLine($"MainWindow: Testing resize on: {firstWindow}");
                    
                    if (_windowResizer != null)
                    {
                        var result = _windowResizer.ResizeWindow(firstWindow, 800, 600);
                        
                        if (result.Success)
                        {
                            Debug.WriteLine($"MainWindow: ✅ {result.DisplayMessage}");
                            this.Title = $"ResizeMe - ✅ Resized {firstWindow.DisplayText} to 800x600";
                            
                            // Also test activation
                            if (_windowResizer.ActivateWindow(firstWindow))
                            {
                                Debug.WriteLine($"MainWindow: ✅ Activated window {firstWindow.DisplayText}");
                            }
                        }
                        else
                        {
                            Debug.WriteLine($"MainWindow: ❌ {result.DisplayMessage}");
                            this.Title = $"ResizeMe - ❌ Failed to resize: {result.ErrorMessage}";
                        }
                        
                        // Log additional details
                        if (result.WindowStateChanged)
                        {
                            Debug.WriteLine($"MainWindow: Window state was changed during resize");
                        }
                        
                        if (result.ActualSize != null)
                        {
                            Debug.WriteLine($"MainWindow: Actual resulting size: {result.ActualSize}");
                        }
                    }
                    else
                    {
                        this.Title = "ResizeMe - WindowResizer not initialized";
                        Debug.WriteLine("MainWindow: WindowResizer is null");
                    }
                }
                else
                {
                    this.Title = "ResizeMe - No resizable windows found";
                    Debug.WriteLine("MainWindow: No resizable windows found");
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"MainWindow: Error during resize test: {ex.Message}");
                this.Title = $"ResizeMe - Error: {ex.Message}";
            }
            
            // Bring our window back to the front
            this.Activate();
        }
```

**Verification:**
- [ ] File should have no build errors
- [ ] WindowResizer field should be recognized by IntelliSense
- [ ] Updated hotkey handler should show resize testing logic
- [ ] All method calls should resolve correctly

---

## Build and Final Verification

**Checklist:**
- [ ] **Build the project:**
   ```powershell
   dotnet build
   ```
   Expected: Build succeeded with 0 errors, 0 warnings

- [ ] **Check for errors:** There should be none. If you see errors:
   - [ ] Verify Models/ResizeResult.cs exists with correct namespace
   - [ ] Check that WindowResizer.cs is in the Services folder
   - [ ] Verify all using statements resolve correctly
   - [ ] Ensure WindowsApi.cs has the new SetWindowPos APIs

- [ ] **Manual Testing:**
   - [ ] Start the application with F5 or `dotnet run`
   - [ ] Open a test application (e.g., Notepad, Calculator)
   - [ ] Note the current size of the test application
   - [ ] Press Ctrl+Alt+R while ResizeMe app is running
   - [ ] Verify the first discovered window gets resized to 800x600
   - [ ] Check that the resized window becomes active (comes to front)
   - [ ] Look at debug output to see detailed resize operation logs
   - [ ] Test with a minimized window to verify state restoration

## Expected Behavior After Completion

- [ ] Application builds and runs without errors
- [ ] Pressing Ctrl+Alt+R discovers windows and resizes the first one to 800x600
- [ ] Debug output shows detailed resize operation information
- [ ] Window title updates to show success/failure of resize operation
- [ ] Minimized windows are properly restored before resizing
- [ ] Resized window becomes active and visible
- [ ] Error handling provides clear messages for common failure scenarios
- [ ] ResizeResult provides detailed information about the operation

## Troubleshooting

| Issue | Solution |
|-------|----------|
| "Build error: Type 'WindowSize' could not be found" | Verify Models/ResizeResult.cs exists and contains the WindowSize class definition |
| "Build error: Type 'WindowResizer' could not be found" | Verify Services/WindowResizer.cs exists with correct namespace `ResizeMe.Services` |
| "SetWindowPos failed with error 5 (Access denied)" | The target window is owned by a privileged process. Test with regular user applications like Notepad |
| "Window resize appears to work but size doesn't change" | Some applications have minimum/maximum size constraints. Try different applications |
| "Resize works but window doesn't activate" | This is normal for some window types. The resize operation is still successful |
| "Exception during resize operation" | Check the specific error message in debug output. May need to add more error handling for specific scenarios |
| "Window state restoration fails" | Some applications don't respond to ShowWindow commands. This is expected behavior for certain app types |

## Files Created/Modified

- [ ] ✅ Modified: `ResizeMe/Native/WindowsApi.cs` (added SetWindowPos and window state APIs)
- [ ] ✅ Created: `ResizeMe/Models/ResizeResult.cs`
- [ ] ✅ Created: `ResizeMe/Services/WindowResizer.cs`
- [ ] ✅ Modified: `ResizeMe/MainWindow.xaml.cs` (added resize testing)
- [ ] ✅ No changes to: Package.appxmanifest (capabilities sufficient from PR 1.1)

## Commit Message Template

```
feat(resize): implement window resize functionality with SetWindowPos

Adds comprehensive window resizing capability with error handling and state management.
Completes core infrastructure for window manipulation.

- Extend WindowsApi with SetWindowPos and window state management APIs
- Create ResizeResult model with detailed operation feedback
- Implement WindowResizer service with robust error handling  
- Add window state restoration for minimized/maximized windows
- Test integration resizes first discovered window to 800x600
- Support window activation after successful resize

Fixes: Core window manipulation functionality for resize menu
```

## Implementation Notes for Reviewers

This implementation provides comprehensive window resize functionality with proper handling of edge cases. The WindowResizer service includes extensive error handling for common scenarios like access denied, invalid handles, and window state issues. The ResizeResult model provides detailed feedback for debugging and future UI implementation. Window state management ensures minimized/maximized windows are properly restored before resizing. The error message system translates Windows API error codes into user-friendly messages.

## What Comes Next

Once this PR is merged:
- Phase 1 is complete - all core infrastructure is implemented
- PR 2.1 (Main Window Layout) can begin, which will create the floating context menu UI
- This provides the foundation for the user-facing resize interface
- Consider future: May want to add preset size validation and screen boundary checking